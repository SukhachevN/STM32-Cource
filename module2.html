<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Методические указания.</title>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Модуль 2</h1>
        <h2>Содержание</h2>
        <nav>
          <ol>
            <li><a href="#introduction">Введение</a></li>
            <li>
              <a href="#module2-1">Работа с 7-ми сегментным дисплеем</a>
            </li>
            <li>
              <a href="#module2-2">Работа с ЖКИ</a>
            </li>
            <li>
              <a href="#module2-3"
                >Работа с клавиатурой. Вывод номера нажатой клавиши.</a
              >
            </li>
            <li><a href="#module2-4">Калькулятор</a></li>
          </ol>
        </nav>
      </header>
      <section id="introduction">
        <h2>Введение</h2>
        <section>
          <h3>Теоретическая часть</h3>
          TODO
        </section>
      </section>
      <section id="module2-1">
        <h3>Модуль 2.1. Работа с 7-ми сегментным индикатором</h3>
        <h4>Задание</h4>
        <p>
          Вывести на 7-ми сегментный индикатор заданную последовательность чисел
          с задержкой 1 сек.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Числа: A,2,F,8,1 тип индикатора: BCD, порты: PA0,PB0,PB1,PC13</li>
          <li>
            Числа: 9,B,4,8,5 тип индикатора: DIGITAL, порты:
            PA0,PA1,PA2,PC3,PC4,PC5,PD1
          </li>
          <li>Числа: 1,4,8,A,F тип индикатора: BCD, порты: PB0,PB5,PB8,PD10</li>
          <li>
            Числа: 0,C,D,3,6 тип индикатора: DIGITAL, порты:
            PA7,PA8,PC1,PC7,PC2,PC12,PA9
          </li>
          <li>Числа: 1,C,B,4,E тип индикатора: BCD, порты: PE15,PC4,PB3,PA0</li>
          <li>
            Числа: F,D,E,C,A тип индикатора: DIGITAL, порты:
            PE6,PD13,PA0,PC4,PB2,PC1,PD5
          </li>
          <li>
            Числа: 2,0,7,5,B тип индикатора: BCD, порты: PA3,PE4,PD14,PC13
          </li>
          <li>
            Числа: 9,E,B,1,3 тип индикатора: DIGITAL, порты:
            PС9,PB3,PE0,PA5,PB11,PE7,PC4
          </li>
          <li>
            Числа: 6,5,E,F,2 тип индикатора: BCD, порты: PA3,PE4,PD14,PC10
          </li>
          <li>
            Числа: 7,8,9,A,B тип индикатора: DIGITAL, порты:
            PA1,PB2,PC3,PD4,PE6,PE6,PC9
          </li>
          <li>
            Числа: 4,2,8,D,A тип индикатора: BCD, порты: PB0,PA11,PE14,PC7
          </li>
          <li>
            Числа: 8,D,0,1,3 тип индикатора: DIGITAL, порты:
            PA1,PB2,PC3,PD4,PE6,PE6,PC9
          </li>
          <li>Числа: E,C,1,5,7 тип индикатора: BCD, порты: PE8,PA3,PE9,PB13</li>
        </ol>
        <p>
          Вывод цифры "D" и "B" сделать как "d" и "b" для вариантов с типом
          индикатора DIGITAL.<br />
          Порты расположены в порядке сверху вниз для типа DIGITAL, и слева
          направо для типа BCD
        </p>
        <h4>Подключение 7-ми сегментного индикатора</h4>
        <p>
          Будут рассмотрены два типа 7-ми сегментных индикаторов: 1-ый тип
          принимает 7-ми сегментные коды, в соответствии с чем зажигает
          соответствующие сегменты. 2-ой тип принимает 4х разрядный двоичный
          код, в зависимости от которого выводятся числа от 0 до F
        </p>
        <p>
          Рассмотрим оба варианта. Создадим проект для микроконтроллера
          <b>STM32F401VE</b>
        </p>
        <p>
          Порты PD0-PD6 и PD10-PD13 назначаем GPIO_Output, это необходимо чтобы
          подавать сигналы на эти порты
        </p>
        <div class="imageBlock">
          <img src="./images/module_2/introduction-1.png" />
          <p>Рисунок 1 Назначение портов для вывода</p>
        </div>
        <p>По итогу должно получиться следующее</p>
        <div class="imageBlock">
          <img src="./images/module_2/introduction-2.png" />
          <p>Рисунок 2 Назначение портов для вывода</p>
        </div>
        <p>
          Чтобы осуществить вывод на нужный порт, необходимо использовать
          следующую команду
        </p>
        <pre>
              HAL_GPIO_WritePin(GPIOX,GPIO_PIN_X,value);
            </pre
        >
        <p>
          GPIOX - X это буква порта, для портов A это будет GPIOA, для портов B
          соответственно GPIOB и так далее. GPIO_PIN_X - X это номер порта, для
          выбора порта с номером 0 это будет GPIO_PIN_0 и так далее. value - это
          значение, которое подаём на порт 0 или 1.
        </p>
        <p>
          Или чтобы осуществить запись сразу нескольких портов одной буквы,
          можно воспользоваться командой:
        </p>
        <pre>
          GPIOX->ODR = value;
        </pre>
        <p>
          Для удобства в этом задание предполагается использовать вариант для
          записи в конкретный порт
        </p>
        <p>Напишем код для вывода числа 9 на 7-ми сегментный индикатор</p>
        <pre>
              // 7 seg code
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_0,1);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_1,1);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,1);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_3,1);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_4,0);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_5,1);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_6,1);
              // BCD code
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_10,1);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_11,0);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_12,0);
              HAL_GPIO_WritePin(GPIOD,GPIO_PIN_13,1);
            </pre
        >
        <p>
          Компилируем проект, не забыв включить вывод hex файла в настройках
        </p>
        <p>
          Перейдём к созданию проекта в среде Proteus. Аналогично модулю 1
          добавляем микроконтроллер <b>STM32F401VE</b>. Далее в добавим 7-ми
          сегментные индикаторы. Для этого необходимо ввести "7SEG-BCD" и потом
          "7SEG-DIGITAL" в поисковую строку.
        </p>
        <p>
          Индикатор с 7-ю входами подключаем к портам PD0-PD6, индикатор BCD к
          портам PD10-PD13.
        </p>
        <div class="imageBlock">
          <img src="./images/module_2/introduction-3.png" />
          <p>Рисунок 3 Работа 7-ми сегментных индикаторов</p>
        </div>
        <p>
          Вернёмся к заданию. Чтобы реализовать тестирование включаем UART, если
          он не был включен. Также подключаем COMPIM (Инструкция по настройке
          приведена в модуле 1).
        </p>
        <p>Задержку можно формировать следующей командой:</p>
        <pre>
          HAL_Delay(value);
        </pre>
        <p>value значение задержки в мс.</p>
        <p>
          Для корректного тестирования, подавать данные на компорт в следующем
          формате
        </p>
        <pre>
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%d...%d", value1, ..., valueN), 100);
        </pre>
      </section>
      <section id="module2-2">
        <h3>Модуль 2.2. Работа с ЖКИ</h3>
        <h4>Задание</h4>
        <p>
          Вывести на ЖКИ свои имя, фамилию и номер группы. Подключение сделать в
          соответствии с вариантом
        </p>
        <p>Варианты</p>
        <ol class="math">
          <li>
            RS: PB1, E: PE12, D0-D7: PA2, PA14, PC2, PE11, PD2, PD3, PD15, PE13
          </li>
          <li>
            RS: PA3, E: PE1, D0-D7: PC1, PA4, PD7, PE8, PA2, PD3, PB5, PA1
          </li>
          <li>
            RS: PE5, E: PD1, D0-D7: PD9, PB2, PC11, PA1, PD2, PE6, PA15, PD14
          </li>
          <li>
            RS: PC13, E: PB2, D0-D7: PC4, PD1, PD2, PA13, PE2, PD3, PE5, PE1
          </li>
          <li>
            RS: PA1, E: PB0, D0-D7: PA0, PA11, PA2, PD0, PD1, PD3, PD15, PC0
          </li>
          <li>
            RS: PD7, E: PA2, D0-D7: PC3, PA4, PD5, PE6, PD1, PB9, PD11, PE7
          </li>
          <li>
            RS: PB10, E: PC5, D0-D7: PE4, PB2, PC12, PD2, PD3, PD14, PD15, PE15
          </li>
          <li>
            RS: PA1, E: PA8, D0-D7: PA3, PA0, PB2, PE0, PD0, PD13, PD6, PA11
          </li>
          <li>
            RS: PB4, E: PD0, D0-D7: PD1, PC12, PC13, PE3, PE2, PD3, PD9, PD10
          </li>
          <li>
            RS: PB11, E: PE0, D0-D7: PA1, PB14, PC2, PE10, PD2, PD9, PD15, PE11
          </li>
          <li>
            RS: PE4, E: PC1, D0-D7: PC2, PA14, PC2, PE11, PD2, PD3, PD15, PC6
          </li>
          <li>
            RS: PC6, E: PB2, D0-D7: PD2, PE14, PD9, PE13, PD1, PD0, PE2, PC3
          </li>
        </ol>
        <h4>Подключение ЖКИ</h4>
        <p>
          Для подключения необходимо устанавить порты заданные вариантом в
          состояние GPIO_Output
        </p>
        <p>В папку core > src, добавить файлы "LCD2004.h" и "LCD2004.c"</p>
        <div class="imageBlock">
          <img src="./images/module_2/module2_2-1.png" />
          <p>Рисунок 4 Добавление библиотечных файлов</p>
        </div>
        <p>
          В этих файлах находятся уже готовые функции для работы с ЖКИ.
          Рассмотрим основные функции на примере.
        </p>
        <p>
          Чтобы начать пользоваться готовыми функциями необходимо подключить
          библиотеку, для этого добавить в main.c:
        </p>
        <pre>#include "LCD2004.h"</pre>
        <p>Рассмотрим библиотечные функции на примере:</p>
        <pre>
          LCD_init_port("D0","D",0);
          LCD_init_port("D1","D",1);
          LCD_init_port("D2","D",2);
          LCD_init_port("D3","D",3);
          LCD_init_port("D4","D",4);
          LCD_init_port("D5","D",5);
          LCD_init_port("D6","D",6);
          LCD_init_port("D7","D",7);
          LCD_init_port("RS","D",9);
          LCD_init_port("E","D",10);
          LCD_init();
          char str[10];
          sprintf(str, "%d", 10000);
          LCD_set_cursor(0,0);
          LCD_print("TEST1", huart1);
          LCD_set_cursor(5,1);
          LCD_print("TEST2", huart1);
          LCD_set_cursor(10,2);
          LCD_print("TEST3", huart1);
          LCD_set_cursor(15,3);
          LCD_print(str, huart1);
        </pre>
        <p>
          LCD_init_port(name, letter, number) - назначает порт name ЖКИ, на порт
          буквы letter, с номером number. Например LCD_init_port("D0","D",0) -
          назначит порт D0 ЖКИ на порт D0 микроконтроллера. Назначать порты для
          корректной работы необходимо до выполнения других функций.
        </p>
        <p>
          LCD_init() - инициализировать ЖКИ. LCD_set_cursor(x,y) - устанавливает
          начало записи на заданные координаты.
        </p>
        <p>
          LCD_print(string, uart) - вывести на ЖКИ сообщение. uart - передать на
          какой UART будет производиться вывод для тестирования. Чтобы вывести
          на ЖКИ число, его необходимо привести к строке
        </p>
        <p>
          Скомпилируем проект и перейдём к созданию проекта в системе Proteus
        </p>
        <p>
          Разместим микроконтроллер. Далее добавим COMPIM для тестирования.
          Чтобы добавить ЖКИ в поисковой строке вводим "LM044L"
        </p>
        <p>
          К порту VDD подключить POWER, к портам VSS и RW подключить GROUND,
          остальные порты в соотвествии с примером
        </p>
        <div class="imageBlock">
          <img src="./images/module_2/module2_2-2.png" />
          <p>Рисунок 4 Итоговая схема</p>
        </div>
        <p>
          Соединить порты в соответствии с вариантом, осуществить тестирование
        </p>
      </section>
      <section id="module2-3">
        <h3>Модуль 2.3. Работа с клавиатурой</h3>
        <h4>Задание</h4>
        <p>
          Рассмотреть программу пример, модифицировать сделав вывод нажатой
          клавиши через отправку ASCII кода на ЖКИ. Соединить порты клавиатуры в
          соответствии с вариантом. Подключение ЖКИ использовать как в модуле
          2.2.
        </p>
        <ol class="math">
          <li>
            Входы клавиатуры: PB2,PB3,PA4; выходы клавиатуры: PA1,PA3,PE2,PE3
          </li>
          <li>
            Входы клавиатуры: PB1,PD2,PA7; выходы клавиатуры: PB11,PA13,PE12,PC3
          </li>
          <li>
            Входы клавиатуры: PE0,PD0,PA0; выходы клавиатуры: PB1,PA2,PE3,PD4
          </li>
          <li>
            Входы клавиатуры: PC12,PD7,PD0; выходы клавиатуры: PC1,PA15,PE4,PD11
          </li>
          <li>
            Входы клавиатуры: PE1,PD9,PD13; выходы клавиатуры: PB1,PB2,PC4,PE7
          </li>
          <li>
            Входы клавиатуры: PA1,PB10,PC3; выходы клавиатуры: PC1,PE4,PD13,PC2
          </li>
          <li>
            Входы клавиатуры: PB0,PE10,PC0; выходы клавиатуры: PA1,PB8,PD5,PC9
          </li>
          <li>
            Входы клавиатуры: PD14,PA7,PE1; выходы клавиатуры:
            PD11,PC8,PD10,PA14
          </li>
          <li>
            Входы клавиатуры: PC1,PC2,PC3; выходы клавиатуры: PD3,PA7,PD11,PE14
          </li>
          <li>
            Входы клавиатуры: PA4,PA9,PC12; выходы клавиатуры: PB13,PA0,PD0,PE5
          </li>
          <li>
            Входы клавиатуры: PC3,PD7,PB12; выходы клавиатуры: PA1,PD4,PE0,PB5
          </li>
          <li>
            Входы клавиатуры: PE0,PD15,PB15; выходы клавиатуры: PC2,PA7,PB0,PC11
          </li>
        </ol>
        <h4>Опрос клавиатуры</h4>
        <p>
          При создании проекта назначаем три выхода путём установки статуса
          GPIO_Output и четыре входа путём установки GPIO_Input
        </p>
        <p>
          Принцип опроса таков: изначально на все столбцы подаётся высокий
          сигнал(1), далее поочерёдно на столбцы подаётся сигнал низкого
          уровня(0). В этот момент, поочерёдно опрашивается 4 строки, при
          нажатии клавиши, клавиатура подаёт сигнал низкого уровня, по нему и
          определяем была ли нажата кнопка.
        </p>
        <p>Напишем функцию для подачи 1 на столбцы</p>
        <pre>
          void setVCC() {
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, 1);
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, 1);
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, 1);
          }
        </pre>
        <p>Далее напишем функцию для опроса строк</p>
        <pre>
          int readRow() {
            if (HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_0) == 0) {
              return 0;
            } else if (HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_1) == 0) {
              return 1;
            } else if (HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_2) == 0) {
              return 2;
            } else if (HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_3) == 0) {
              return 3;
            }
            return -1;
          }
        </pre>
        <p>
          Получаем номер строки в которой нажата клавиша, либо -1 в случае, если
          ничего не нажато
        </p>
        <p>
          Теперь реализуем алгоритм. Итоговая программа выглядит следующим
          образом:
        </p>
        <pre>
          int currentKey;
          int lastKey;
          int readKey;
          void setVCC() {
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, 1);
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, 1);
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, 1);
          }
          int readRow() {
            if (HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_0) == 0) {
              return 0;
            } else if (HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_1) == 0) {
              return 1;
            } else if (HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_2) == 0) {
              return 2;
            } else if (HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_3) == 0) {
              return 3;
            }
            return -1;
          }
          ...
          while (1)
          {
            int i;
            for (i = 0; i < 3; i++) {
              setVCC();
              switch (i){
                case 0:
                  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, 0);
                break;
                case 1:
                  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, 0);
                break;
                case 2:
                  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, 0);
                break;
              }
              readKey = readRow();
              if (readKey != -1) {
                currentKey = readKey*3+i;
              }
            }
            if (currentKey != lastKey) {
              char buffer[3];
              HAL_UART_Transmit(&huart1, buffer,  sprintf(buffer, "%d", currentKey), 100);
              lastKey = currentKey;
            }
            HAL_Delay(200);

            /* USER CODE BEGIN 3 */
          }
        </pre>
        <p>
          С полным кодом можно ознакомиться в папке exercise/module2/module2-3
        </p>
        <p>Для вывода ASCII кода воспользоваться функцией LCD_ASCII</p>
        <pre>LCD_ASCII(code, uart)</pre>
        <p>
          code - ascii код, uart указатель на какой uart должно отправляться
          сообщение для тестирования
        </p>
        <p>Перейдём к системе Proteus</p>
        <p>Чтобы добавить клавиатуру, вводим в поисковой строке KEYPAD-PHONE</p>
        <p>
          Как обычно размещаем микроконтроллер, COMPIM, и клавиатуру, подключаем
          всё
        </p>
        <div class="imageBlock">
          <img src="./images/module_2/module2_3-1.png" />
          <p>Рисунок 4 Итоговая схема</p>
        </div>
        <p>
          При нажатии выводится порядковый номер клавиши на виртуальный
          терминал. Номера расположены сверху вниз, слева направо в порядке
          возрастания.
        </p>
        <p>
          Используя функцию LCD_ASCII реализовать вывод нажатой клавиши через
          ASCII код. Важно учитывать, что нужно возвращать курсор в исходную
          позицию после каждого нажатия на клавишу. Клавиатуру подсоединить в
          соответствии с вариантом. Выполнить тестирование.
        </p>
        <p>
          Фразу "LAST KEY PRESSED - " выводить только один раз. При нажатии
          должен обновляться только символ
        </p>
        <p><a href="https://www.ascii-code.com/">Таблица ASCII кодов</a></p>
      </section>
      <section id="module2-4">
        <h3>Модуль 2.4. Калькулятор</h3>
        <h4>Задание</h4>
        <p>
          Модифицировать код из модуля 2.3, подключить клавиатуру калькулятора
          4х4, реализовать калькулятор на два операнда. С клавиатуры вводятся
          числа и знаки, по нажатию на клавишу '=' очищается поле и выводится
          результат. По нажатию на клавишу 'on/c' производится очистка экрана.
        </p>
        <p>
          * Задание повышенной сложности: реализовать колькулятор на 3 операнда
          с учётом порядка действий. По желанию можно увеличить количество
          операндов.
        </p>
        <p>Ответ выводит в формате float с точностью 2 знака после запятой</p>
        <p>
          Чтобы считать число более чем 2 знака, можно записывать после каждого
          нажатия клавиши её значение в буффер. Полезной будет команда
          strcat(buffer, value), нужно подключить библиотеку "string.h".
        </p>
        <p>
          Для перевода из строки в число можно воспользоваться командой
          atoi(value), нужно подключить библиотеку "stdlib.h".
        </p>
        <p>Очистить буффер можно командой memset(buffer, 0, sizeof buffer);</p>
      </section>
    </div>
  </body>
</html>
