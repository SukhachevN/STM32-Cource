<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Методические указания.</title>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Модуль 4</h1>
        <h2>Содержание</h2>
        <nav>
          <ol>
            <li><a href="#introduction">Введение</a></li>
            <li>
              <a href="#module4-1">UART - простые операции</a>
            </li>
            <li>
              <a href="#module4-2"
                >UART - перевод чисел из десятичной системы в римскую</a
              >
            </li>
            <li>
              <a href="#module4-3">UART - управление сервомотором</a>
            </li>
          </ol>
        </nav>
      </header>
      <section id="introduction">
        <h2>Введение</h2>
        <section>
          <h3>Теоретическая часть</h3>
          <h4>UART</h4>
          <p>
            UART (или USART) – расшифровывается как Universal Asynchronous
            Receiver-Transmitter, что на русском означает универсальный
            асинхронный приемопередатчик. Это один из наиболее распространенный
            последовательный интерфейс передачи данных. По этому интерфейсу
            возможно соединить микроконтроллер с разными устройствами, начиная
            от датчиков, заканчивая комптютерами. В данном курсе лабораторных
            работ, этот интерфейс использовался в каждом модуле для отладки и
            для передачи данных на компорт для тестировани.
          </p>
          <div class="imageBlock">
            <img src="./images/module_4/t-1.png" />
            <p>Рисунок 1 Пример передачи по UART.</p>
          </div>
          <p>
            Передача данных в UART последовательная и асинхронная. То есть при
            передачи не нужны отдельные синхронизирующие импульсы, данные могут
            начать передаваться в любое время, так как передаваемый сигнал
            содержит как синхронизирующую информацию так и данные.
          </p>
          <p>
            Синхронизирующими в сигнале являются два бита: старт бит и стоп бит.
          </p>
          <p>
            Если приемник находится в режиме ожидания, то сигнал на его входе
            будет высокого уровня. Старт бит имеет низкий уровень, после
            получения старт бита начинается отсчёт состояния последующих 8-ми
            бит. В конце сигнала располагется стоп бит, имеющий высокий уровень.
          </p>
          <p>
            Каждый бит должен передаваться за одинаковое количество времени,
            которое и определяет скорость передачи UART. Единица скорости
            передачи - бод, тоже самое что и бит в секунду. Обычно погрешность
            скорости передачи не превышает 1.5%, по правилам интерфейса возможна
            погрешность до 5%.
          </p>
          <p>
            В общем случае для передачи одного байта информации требуется 10
            бит: 8 бит данные и 2 для синхронизации. Существуют варианты с
            данными от 5 до 9 бит, также бывает по два стоп бита, и бывает бит
            четности. Рисунок с расположением всех возможных битов приведён
            ниже.
          </p>
          <div class="imageBlock">
            <img src="./images/module_4/t-2.png" />
            <p>Рисунок 2 Формат сигнала в UART.</p>
          </div>
          <p>Ключевые особенности UART:</p>
          <ul>
            <li>
              В режиме ожидания порт выход передатчика всегда имеет высокий
              уровень сигнала.
            </li>
            <li>
              Передача всегда начинается с одного стартового бита, имеющего
              низкий уровень и заканчивается одним или двумя стоп битами
              имеющими высокий уровень.
            </li>
            <li>Передача идёт начиная с младших бит.</li>
            <li>
              Скорость передачи байта информации зависит от скорости интерфейса
              и количества бит в сигнале.
            </li>
          </ul>
          <p>
            Относительно скорость работы UART имеется много стандартов, но
            наиболее популярны стандартные скорости:
          </p>
          <ul>
            <li>4800 бод, время передачи одного бита 208 мкс</li>
            <li>9600 бод, время передачи одного бита 104 мкс</li>
            <li>19200 бод, время передачи одного бита 52 мкс</li>
            <li>38400 бод, время передачи одного бита 26 мкс</li>
            <li>57600 бод, время передачи одного бита 17 мкс</li>
            <li>115200 бод, время передачи одного бита 8,7 мкс</li>
          </ul>
          <p>
            В микроконтроллерах STM32 UART может работать во многих режимах, они
            приведены на рисунке ниже.
          </p>
          <div class="imageBlock">
            <img src="./images/module_4/t-3.png" />
            <p>Рисунок 3 Режимы работы UART в STM32.</p>
          </div>
          <p>
            Одним из самых популярных является асинхронный режим. При
            использовании этого режима у двух устройств соединяются порты RX с
            TX, и наоборот. При этом для корректной работы у двух устройств
            должна быть выбрана одинаковая скорость передачи и формат сигнала.
          </p>
          <p>
            На рисунке ниже приведена часть функциональной схемы интерфейса,
            через которую происходит обмен данными.
          </p>
          <div class="imageBlock">
            <img src="./images/module_4/t-4.png" />
            <p>Рисунок 4 Схема передачи.</p>
          </div>
          <p>
            Работа приемной и отправляющей частей независимы, однако они
            соединены общим тактовым генератором. Также у обоих частей одниковые
            формат данных и скорость работы.
          </p>
          <p>
            Передающая часть состоит из двух регистров: сдвиговый регистра TSR и
            буфер TDR.
          </p>
          <p>
            Данные помещаются в регистр буфера(он является программно
            доступным). Если была закончена передача предыдущих данных , то
            новые данные переносятся в буфер, после чего побитово сдвинаются и
            передаются на выход TX. По завершению сдвигов, буфер освобождается,
            и способен принять новые данные. Такой процесс буферицации позволяет
            избежать задержек между передачей слов. После загрузки буферного
            регистра есть некоторое время на запись новых данных, это время
            равняется времени передачи. По окончанию передачи данных регистром
            сдвига и освобождению буфера формируются флаги, по этим флагам, в
            зависимости от настроек могу формироваться прерывания.
          </p>
          <p>
            Приемная часть состоит из регистра сдвига RSF и регистра буфера RDR.
          </p>
          <p>
            Со входа RX данные переносятся на сдвиговый регистр, сдвигаются до
            формирования слова, после чего передаются в буфер(доступен
            програмно).Из буфера могут считываться данные. Если данные поступают
            сплошным потоком, без пауз, то после приема данных есть некоторое
            время, равное времени передачи слова, чтобы считать данные из
            регистра буфера. Если бы это времени не было, то полученное слово
            терялось бы из-за получения следующего.
          </p>
          <p>У USART имеется много регистров, ниже приведены наиболее важные</p>
          <ul>
            <li>USART_SR - регистр состояния.</li>
            <li>USART_DR - регистр данных.</li>
            <li>USART_BRR - регистр, задающий скорость обмена.</li>
            <li>USART_CR1 – управляющий регистр 1.</li>
            <li>USART_CR2 – управляющий регистр 2.</li>
            <li>USART_CR3 – управляющий регистр 3.</li>
          </ul>
          <h4>Римская система счисления</h4>
          <p>
            В данном модуле основным заданием будет реализация перевода чисел из
            десятичной в римскую систему счисления. Использование этого задания
            как основного выбрана из-за того что удобно разделить обязанности
            между двумя микроконтроллерами, и соединить их по одному из
            рассматриваемых интерфейсов UART или SPI. Один микроконтроллер
            выполняет обработку вводимых значений с клавиатуры, в другой
            выполняет перевод.
          </p>
          <p>Всего можно выделить следующие знаки:</p>
          <ul>
            <li>I = 1</li>
            <li>V = 5</li>
            <li>X = 10</li>
            <li>L = 50</li>
            <li>C = 100</li>
            <li>D = 500</li>
            <li>M = 1000</li>
          </ul>
          <p>
            С помощью этих знаков можно записать любое целое число в диапазоне
            от 1 до 3999. Числа более 3999, записываются с помощью добавления
            черты над над знаком, что означает увеличение в 1000 раз.
          </p>
          <p>
            Если большая цифра стоит перед меньшей, то значения этих цифр
            складываются. Например VI = 5 + 1 = 6, XV = 10 + 5 = 15 и так далее.
          </p>
          <p>
            Если большая цифра стоит после меньшей, это означает вычитание из
            большей цифры значение меньшей. Например IV = 5 - 1 = 4, IX = 10 - 1
            = 9 и так далее. Вычитаться могут только цифры, обозначающие 1 или
            степени 10; уменьшаемым может быть только цифра, ближайшая в
            числовом ряду к вычитаемой
          </p>
          <p>
            Цифры V, L, D не могут повторяться; цифры I, X, C, M могут
            повторяться не более трех раз подряд.
          </p>
        </section>
      </section>
      <section id="module4-1">
        <h3>Модуль 4.1. UART - простые операции</h3>
        <h4>Задание</h4>
        <p>
          Реализовать обмен данными по UART между двумя микроконтроллерами, в
          соответсвии с заданием варианта. Микроконтроллер 1, по номеру UART_A,
          передаёт заданное число B на микроконтроллер 2, на вход UART_C. После
          чего выполняет действие D, и выводит результат на UART_E. Приём данных
          по UART осуществляется методом F.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>A: 1, B: 100, C: 2, D: умножить на 2, E: 6, F: блокирующий</li>
          <li>A: 2, B: 1000, C: 6, D: делить на 2, E: 1, F: с прерыванием</li>
          <li>A: 6, B: 40, C: 1, D: прибавить 8, E: 2, F: блокирующий</li>
          <li>A: 1, B: 12, C: 2, D: вычесть на 3, E: 6, F: с прерыванием</li>
          <li>A: 2, B: 17, C: 6, D: прибавить на 10, E: 1, F: блокирующий</li>
          <li>A: 6, B: 654, C: 1, D: делить на 3, E: 6, F: с прерыванием</li>
          <li>A: 1, B: 321, C: 2, D: умножить на 10, E: 6, F: блокирующий</li>
          <li>A: 2, B: 123, C: 6, D: вычесть 100, E: 1, F: с прерыванием</li>
          <li>A: 6, B: 0, C: 1, D: прибавить на 25, E: 2, F: блокирующий</li>
          <li>A: 1, B: 32, C: 2, D: делить на 8, E: 2, F: с прерыванием</li>
          <li>A: 2, B: 57, C: 6, D: умножить на 10, E: 6, F: блокирующий</li>
          <li>A: 6, B: 6, C: 1, D: вычесть 5, E: 1, F: с прерыванием</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>
          Для разных методов приёма необходимы разные настройки проекта, однако
          имеется общие этапы.
        </p>
        <p>
          Создать проект, все действия по созданию проекта аналогичны предыдущим
          модулям, до этапа настроек.
        </p>
        <p>Включить тактирование.</p>
        <h4>Настройка проекта для блокирующего метода получения</h4>
        <p>
          Для данного метода получения, необходимо просто включить UART, не
          производя никаких дополнительных настроек.
        </p>
        <p>Сгенерировать код, после генерации включить создание hex-файла.</p>
        <p>
          Для примера будет считываться строка, записываться в буфер, и сразу же
          выводиться
        </p>
        <pre>
            uint8_t buffer[100] = {0};
            while (1)
            {
              /* USER CODE END WHILE */
                HAL_UART_Receive (&huart1, buffer, 100, 100);
                HAL_UART_Transmit(&huart1, buffer, 100, 100);
                memset(buffer, 0, 100);
              /* USER CODE BEGIN 3 */
            }</pre
        >
        <p>
          Как и в предыдущих модулях, необходимо объявить буфер, для хранения
          данных.
        </p>
        <p>
          Считывание входных данных осуществляется командой HAL_UART_Receive
          (&huart1, buffer, 100, 100); как параметры передаются указатель на
          UART, буфер, длина считываемой строки, в этом примере это 100 (3-ий
          параметр), а также задержка на считывание(4ый параметр), это 100 или
          0.1 секунды. Это означает что как только цикл начнётся данные будут
          ожидаться ровно 0.1 секунды, блокируя выполнение остальной программы,
          после чего, всё что было получено будет записано в буфер. Можно
          поэкспериментировать устанавливая разное время задержки и посмотреть
          на результат. Данный способ приема применяется только если
          микроконтроллер не выполняет других операций кроме операций с
          получаемыми данными.
        </p>
        <p>
          Строка memset(buffer, 0, 100) необходима для очистки буфера, чтобы при
          новом цикле не выводилось старое значение буфера.
        </p>
        <p>Скомпилировать код, перейти к созданию проекта в среде Proteus.</p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Данные этап одинаковый для всех методов, поэтому будет описан только
          один раз.
        </p>
        <p>
          Разместить микроконтроллер, подключить виртуальные терминалы, как
          указано на рисунке ниже.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-1.png" />
          <p>Рисунок 1 схема в Proteus.</p>
        </div>
        <p>
          Установить baud rate для виртуальных терминалов равным 115200. С
          помощью одного виртуального терминала на микроконтроллер будут
          отправляться данные, а выводиться будут на другой терминал.
        </p>
        <p>Включить отображение печатаемых символов на терминале.</p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-1-2.png" />
          <p>Рисунок 2 включение отображения печатаемых символов.</p>
        </div>
        <p>После этого ввести в терминал любое слово.</p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-1-3.png" />
          <p>Рисунок 3 Результат.</p>
        </div>
        <p>
          Можно будет наблюдать, что вводимые данные дублируются на другом
          терминале.
        </p>
        <h4>Настройка проекта для метода получения по прерыванию.</h4>
        <p>
          Для считывания данных по UART данным методом, необходимо при настройке
          включить прерывание.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-2-1.png" />
          <p>Рисунок 3 Включение прерывания UART.</p>
        </div>
        <p>Далее всё также сгенерировать код.</p>
        <p>
          В случае с прерыванием UART, всё точно также как с прерыванием в
          таймерах.
        </p>
        <p>
          В файле main.c, необходимо объявить буфер, до начала функции main.
        </p>
        <pre>
            uint8_t buffer[100] = {0};
        </pre>
        <p>
          Далее, перед циклом while запустить обработчик запись в буфер по
          прерыванию UART, делается это следующей командой:
        </p>
        <pre>HAL_UART_Receive_IT (&huart1, buffer, 100);</pre>
        <p>
          Как параметры всё также передаются указатель на UART, буфер и длина
          считываемых данных. Однако в этом случае, получение данных не будет
          блокировать выполнение остальной программы. Что очень удобно если в
          исполняемой программе необходимо выполнять какие либо другие действия,
          кроме операций с получаемыми данными.
        </p>
        <p>Обработка прерывания настраивается в файле stm32f4xx_it.</p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-2-2.png" />
          <p>Рисунок 4 Расположение файла настройки прерываний.</p>
        </div>
        <p>
          В первую очередь необходимо сделать, чтобы переменная буфера была
          доступна в файле с обработкой прерываний, делается это следующим
          образом:
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-2-3.png" />
          <p>Рисунок 5 добавление буфера.</p>
        </div>
        <p>
          Теперь можно перейти к обработке прерывания. Для этого надо найти
          функцию отвечающую за прерывания UART.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-2-4.png" />
          <p>Рисунок 6 обработка прерывания.</p>
        </div>
        <p>
          Код немного отличается от случая, когда данные считывались обычным
          способом, так как необходимо запускать следующий обработчик
          прерывания.
        </p>
        <p>
          После написания кода скомпилировать проект, перейти к созданию проекта
          в Proteus, следуюя инструкции описанной ранее.
        </p>
        <p>
          На основе рассмотренных примеров реализовать связь двух
          микроконтроллеров по UART, в соответствии с вариантом, провести
          тестирование.
        </p>
        <p>
          Пример выполненного задания. Микроконтроллер 1, с помощью UART1
          передаёт на микроконтроллер 2 число 1, микроконтроллер 2 также
          принимает число с помощью UART1 и им же выводит.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-1.png" />
          <p>Рисунок 7 Результат.</p>
        </div>
      </section>
      <section id="module3-2">
        <h3>
          Модуль 4.2. UART - перевод чисел из десятичной системы в римскую
        </h3>
        <h4>Задание</h4>
        <p>
          Реализовать следующую схему: на микроконтроллере 1, с клавиатуры
          набираются десятичные числа, имеется возможность ввода до 4х цифр,
          удаления последней цифры, а также кнопка отправления данных на
          микроконтроллер 2. Микроконтроллер 2 ожидает получения десятичного
          числа, по получению производит перевод в римскую систему счисления.
        </p>
        <p>
          Вводимые цифры, а также результат перевод должны выводиться на ЖКИ.
          Диапазон десятичных чисел от 1 до 3999. ( минимальное число в римской
          системе счисления 1, 3999 является самым большим числом, которое можно
          вывести на ЖКИ, без задействия дополнительных символов)
        </p>
        <p>
          * Задание повышенной сложности: реализовать перевод из римской системы
          счисления в десятичную.
        </p>
        <p>
          ** Задание повышенной сложности: реализовать перевод чисел в двух
          направлениях.
        </p>
        <p>Варианты:</p>
        <p>
          Использование портов UART оставить как в задании 4.1, но заменить
          метод получения на противоположный: то есть если был обычный, то
          сделать с прерыванием, если был с прерыванием сделать обычный.
        </p>
        <p>
          Схема может быть как на рисунке ниже. Была задействована клавиатура
          4х3, цифры соответствуют номерам на кнопках, на нажитие "*" сделано
          стирание последней введённой цифры, на кнопку "#" сделана отправка на
          микроконтроллер 2. Для ЖКИ использовать библиотеку LCD вместо LCD2004,
          так как в этом задание не нужно отправлять на UART выводимые данные,
          то будет использоваться библиотека без этой функции.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-2-1.png" />
          <p>Рисунок 8 Схема.</p>
        </div>
      </section>
      <section id="module3-3">
        <h3>Модуль 4.3. Управление сервомотором по UART</h3>
        <h4>Задание</h4>
        <p>
          На основе заданий 3.4 и 4.2 предлагается реализовать управление углом
          поворота сервомотора не через потенциометр, а через задавать с
          клавиатуры микроконтроллера 1 угол, и по UART передавать его на
          микроконтроллер 2.
        </p>
        <p>Подключение портов оставить как в заданиях 3.4 и 4.2.</p>
      </section>
    </div>
  </body>
</html>
