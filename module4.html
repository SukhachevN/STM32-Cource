<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Методические указания.</title>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Модуль 4</h1>
        <h2>Содержание</h2>
        <nav>
          <ol>
            <li><a href="#introduction">Введение</a></li>
            <li>
              <a href="#module4-1">UART - Простые операции</a>
            </li>
            <li>
              <a href="#module4-2">UART - Управление сервомотором</a>
            </li>
            <li>
              <a href="#module4-3"
                >UART - Калькулятор на двух микроконтроллерах</a
              >
            </li>
          </ol>
        </nav>
      </header>
      <section id="introduction">
        <h2>Введение</h2>
        <section>
          <h3>Теоретическая часть</h3>
          <h4>UART</h4>
          <p>
            UART (или USART) – расшифровывается как Universal Asynchronous
            Receiver-Transmitter, что на русском означает универсальный
            асинхронный приемопередатчик. Является одним из самых популярных
            последовательных интерфейсов. С помощью UART, возможно соедининение
            микроконтроллер с различными устройствами, начиная от простых
            датчиков, заканчивая комьютерами. В данном курсе лабораторных работ,
            этот интерфейс использовался в каждом модуле для отладки и для
            передачи данных на компорт для тестирования.
          </p>
          <div class="imageBlock">
            <img src="./images/module_4/t-1.png" />
            <p>Рисунок 1 Пример передачи по UART.</p>
          </div>
          <p>
            Данные в UART передаются последовательно и асинхронно. Это означает,
            что не нужно дополнительно передавать импульсы для синхронизации.
            Передача данных может начаться в любой момент времени, передаваемый
            сигнал будет содержать синхронизирующие биты. Всего их два типа:
            старт бит и стоп бит.
          </p>
          <p>
            Пока приемник находится в режиме ожидания, то на входном порту будет
            сигнал высокого уровня. Стартовый бит всегда низкого уровня, по
            получению старт бита, начинается отсчёт состояний следующих N бит. N
            зависит от настроек UART, в большинстве случаев это будет 8. В конце
            передаваемого сигнала всегда будет стоп бит высокого уровня.
          </p>
          <p>
            Скорость работы UART определяется врменем передачи 1 бита, единица
            измерения - бод, тоже самое что и бит в секунду. В идеальном случае
            каждый бит сигнала должен быть передан за одинаковое время. По
            правилам интерфейса возможна погрешность скорости передачи не более
            чем 5%, но обычно рекомендуется не превышать погрешность в 1.5%.
          </p>
          <p>
            В общем случае для передачи одного байта информации требуется 10
            бит: 8 бит данные и 2 бита для синхронизации. Также существуют
            варианты с данными от 5 до 9 бит, и тремя битами синхронизации: один
            стартовый, два стоповых. Иногда вводится дополнительный бит
            чётности. Рисунок с расположением всех возможных битов приведён
            ниже.
          </p>
          <div class="imageBlock">
            <img src="./images/module_4/t-2.png" />
            <p>Рисунок 2 Формат сигнала в UART.</p>
          </div>
          <p>Ключевые особенности UART:</p>
          <ul>
            <li>
              В режиме ожидания выходной порт передатчика всегда имеет высокий
              уровень сигнала.
            </li>
            <li>
              В начале сигнала всегда следует стартовый бит низкого уровня, а в
              конце стоповый бит высокого уровня.
            </li>
            <li>Передача данных идёт начиная с младших бит.</li>
            <li>
              Скорость передачи одного байта информации определяется от
              скоростью интерфейса и количеством бит в сигнале.
            </li>
          </ul>
          <p>
            Существует много стандартов относительно скорости передачи в UART,
            ниже приведены наиболее популярные стандарты:
          </p>
          <ul>
            <li>4800 бод, время передачи одного бита 208 мкс</li>
            <li>9600 бод, время передачи одного бита 104 мкс</li>
            <li>19200 бод, время передачи одного бита 52 мкс</li>
            <li>38400 бод, время передачи одного бита 26 мкс</li>
            <li>57600 бод, время передачи одного бита 17 мкс</li>
            <li>115200 бод, время передачи одного бита 8,7 мкс</li>
          </ul>
          <p>
            В микроконтроллерах STM32 UART может работать во многих режимах, они
            приведены на рисунке ниже.
          </p>
          <div class="imageBlock">
            <img src="./images/module_4/t-3.png" />
            <p>Рисунок 3 Режимы работы UART в STM32.</p>
          </div>
          <p>
            Одним из самых популярных является асинхронный режим. Для работы в
            этом режиме надо соединить RX и TX порты одного устройства с TX и RX
            портами другого. Также стоит отметить необходимость соблюдения
            формата и скорости обоих устройств, если они различаются, то
            корректной работы быть не может.
          </p>
          <p>
            На рисунке ниже приведена часть функциональной схемы интерфейса,
            через которую происходит обмен данными.
          </p>
          <div class="imageBlock">
            <img src="./images/module_4/t-4.png" />
            <p>Рисунок 4 Схема передачи.</p>
          </div>
          <p>
            Приемная и отправляющая часть имеют единый тактовый генератор,
            скорость и формат данных.
          </p>
          <p>
            Передающая часть состоит из двух регистров: сдвиговый регистр TSR и
            буфер TDR.
          </p>
          <p>
            Данные помещаются в регистр буфера, этот регистр программно
            доступен. В случае, если была закончена передача предыдущих данных ,
            то новые данные переносятся в буфер, после чего побитово сдвигаются
            и передаются на выход TX. Когда все данные сдвинуты, то буфер
            освобождается, и далее способен принять новые данные. По окончанию
            передачи данных регистром сдвига и освобождению буфера, формируются
            специальные флаги, по которым, в зависимости от настроек могут
            формироваться прерывания.
          </p>
          <p>
            Приемная часть состоит из регистра сдвига RSF и регистра буфера RDR.
          </p>
          <p>
            Со входа RX данные переносятся на сдвиговый регистр, после чего
            происходит сдвиг до формирования слова, с последующей передачей в
            буферный регистр. Из буфера могут считываться данные. Если данные
            поступают сплошным потоком, без пауз, то после приема данных есть
            некоторое время, равное времени передачи слова, чтобы считать данные
            из регистра буфера. Если бы это времени не было, то полученное слово
            терялось бы из-за получения следующего.
          </p>
          <p>У USART имеется много регистров, ниже приведены наиболее важные</p>
          <ul>
            <li>USART_SR - регистр состояния.</li>
            <li>USART_DR - регистр данных.</li>
            <li>USART_BRR - регистр, задающий скорость обмена.</li>
            <li>USART_CR1 – управляющий регистр 1.</li>
            <li>USART_CR2 – управляющий регистр 2.</li>
            <li>USART_CR3 – управляющий регистр 3.</li>
          </ul>
          <p>
            В данном модуле, предлагается использовать UART, не только для
            отладки, но и для обмена информацией между двумя микроконтроллерами.
            По UART передавать либо данные, либо команды для управления другим
            микроконтроллером.
          </p>
        </section>
      </section>
      <section id="module4-1">
        <h3>Модуль 4.1. UART - простые операции</h3>
        <h4>Задание</h4>
        <p>
          Реализовать обмен данными по UART между двумя микроконтроллерами, в
          соответсвии с заданием варианта. Микроконтроллер 1, по номеру UART_A,
          передаёт заданное число B на микроконтроллер 2, на вход UART_C. После
          чего выполняет действие D, и выводит результат на UART_E. Приём данных
          по UART осуществляется методом F.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>A: 1, B: 100, C: 2, D: умножить на 2, E: 6, F: блокирующий</li>
          <li>A: 2, B: 1000, C: 6, D: делить на 2, E: 1, F: с прерыванием</li>
          <li>A: 6, B: 40, C: 1, D: прибавить 8, E: 2, F: блокирующий</li>
          <li>A: 1, B: 12, C: 2, D: вычесть на 3, E: 6, F: с прерыванием</li>
          <li>A: 2, B: 17, C: 6, D: прибавить на 10, E: 1, F: блокирующий</li>
          <li>A: 6, B: 654, C: 1, D: делить на 3, E: 6, F: с прерыванием</li>
          <li>A: 1, B: 321, C: 2, D: умножить на 10, E: 6, F: блокирующий</li>
          <li>A: 2, B: 123, C: 6, D: вычесть 100, E: 1, F: с прерыванием</li>
          <li>A: 6, B: 0, C: 1, D: прибавить на 25, E: 2, F: блокирующий</li>
          <li>A: 1, B: 32, C: 2, D: делить на 8, E: 2, F: с прерыванием</li>
          <li>A: 2, B: 57, C: 6, D: умножить на 10, E: 6, F: блокирующий</li>
          <li>A: 6, B: 6, C: 1, D: вычесть 5, E: 1, F: с прерыванием</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>
          Для разных методов приёма необходимы разные настройки проекта, однако
          имеется общие этапы.
        </p>
        <p>
          Создать проект, все действия по созданию проекта аналогичны предыдущим
          модулям, до этапа настроек.
        </p>
        <p>Включить тактирование.</p>
        <h4>Настройка проекта для блокирующего метода получения</h4>
        <p>
          Для данного метода получения, необходимо просто включить UART, не
          производя никаких дополнительных настроек.
        </p>
        <p>Сгенерировать код, после генерации включить создание hex-файла.</p>
        <p>
          Для примера будет считываться строка, записываться в буфер, и сразу же
          выводиться
        </p>
        <pre>
            uint8_t buffer[100] = {0};
            while (1)
            {
              /* USER CODE END WHILE */
                HAL_UART_Receive (&huart1, buffer, 100, 100);
                HAL_UART_Transmit(&huart1, buffer, 100, 100);
                memset(buffer, 0, 100);
              /* USER CODE BEGIN 3 */
            }</pre
        >
        <p>
          Как и в предыдущих модулях, необходимо объявить буфер, для хранения
          данных.
        </p>
        <p>
          Считывание входных данных осуществляется командой HAL_UART_Receive
          (&huart1, buffer, 100, 100); как параметры передаются указатель на
          UART, буфер, длина считываемой строки, в этом примере это 100 (3-ий
          параметр), а также задержка на считывание(4ый параметр), это 100 или
          0.1 секунды. Это означает что как только цикл начнётся данные будут
          ожидаться ровно 0.1 секунды, блокируя выполнение остальной программы,
          после чего, всё что было получено будет записано в буфер. Можно
          поэкспериментировать устанавливая разное время задержки и посмотреть
          на результат. Данный способ приема применяется только если
          микроконтроллер не выполняет других операций кроме операций с
          получаемыми данными.
        </p>
        <p>
          Строка memset(buffer, 0, 100) необходима для очистки буфера, чтобы при
          новом цикле не выводилось старое значение буфера.
        </p>
        <p>Скомпилировать код, перейти к созданию проекта в среде Proteus.</p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Данные этап одинаковый для всех методов, поэтому будет описан только
          один раз.
        </p>
        <p>
          Разместить микроконтроллер, подключить виртуальные терминалы, как
          указано на рисунке ниже.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-1.png" />
          <p>Рисунок 1 схема в Proteus.</p>
        </div>
        <p>
          Установить baud rate для виртуальных терминалов равным 115200. С
          помощью одного виртуального терминала на микроконтроллер будут
          отправляться данные, а выводиться будут на другой терминал.
        </p>
        <p>Включить отображение печатаемых символов на терминале.</p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-1-2.png" />
          <p>Рисунок 2 включение отображения печатаемых символов.</p>
        </div>
        <p>После этого ввести в терминал любое слово.</p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-1-3.png" />
          <p>Рисунок 3 Результат.</p>
        </div>
        <p>
          Можно будет наблюдать, что вводимые данные дублируются на другом
          терминале.
        </p>
        <h4>Настройка проекта для метода получения по прерыванию.</h4>
        <p>
          Для считывания данных по UART данным методом, необходимо при настройке
          включить прерывание.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-2-1.png" />
          <p>Рисунок 3 Включение прерывания UART.</p>
        </div>
        <p>Далее всё также сгенерировать код.</p>
        <p>
          В случае с прерыванием UART, всё точно также как с прерыванием в
          таймерах.
        </p>
        <p>
          В файле main.c, необходимо объявить буфер, до начала функции main.
        </p>
        <pre>
            uint8_t buffer[100] = {0};
        </pre>
        <p>
          Далее, перед циклом while запустить обработчик запись в буфер по
          прерыванию UART, делается это следующей командой:
        </p>
        <pre>HAL_UART_Receive_IT (&huart1, buffer, 100);</pre>
        <p>
          Как параметры всё также передаются указатель на UART, буфер и длина
          считываемых данных. Однако в этом случае, получение данных не будет
          блокировать выполнение остальной программы. Что очень удобно если в
          исполняемой программе необходимо выполнять какие либо другие действия,
          кроме операций с получаемыми данными.
        </p>
        <p>Обработка прерывания настраивается в файле stm32f4xx_it.</p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-2-2.png" />
          <p>Рисунок 4 Расположение файла настройки прерываний.</p>
        </div>
        <p>
          В первую очередь необходимо сделать, чтобы переменная буфера была
          доступна в файле с обработкой прерываний, делается это следующим
          образом:
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-2-3.png" />
          <p>Рисунок 5 добавление буфера.</p>
        </div>
        <p>
          Теперь можно перейти к обработке прерывания. Для этого надо найти
          функцию отвечающую за прерывания UART.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-intro-2-4.png" />
          <p>Рисунок 6 обработка прерывания.</p>
        </div>
        <p>
          Код немного отличается от случая, когда данные считывались обычным
          способом, так как необходимо запускать следующий обработчик
          прерывания.
        </p>
        <p>
          После написания кода скомпилировать проект, перейти к созданию проекта
          в Proteus, следуюя инструкции описанной ранее.
        </p>
        <p>
          На основе рассмотренных примеров реализовать связь двух
          микроконтроллеров по UART, в соответствии с вариантом, провести
          тестирование.
        </p>
        <p>
          Пример выполненного задания. Микроконтроллер 1, с помощью UART1
          передаёт на микроконтроллер 2 число 1, микроконтроллер 2 также
          принимает число с помощью UART1 и им же выводит.
        </p>
        <div class="imageBlock">
          <img src="./images/module_4/4-1-1.png" />
          <p>Рисунок 7 Результат.</p>
        </div>
      </section>
      <section id="module4-2">
        <h3>Модуль 4.2. UART - управление сервоприводом.</h3>
        <h4>Задание</h4>
        <p>
          Реализовать следующую схему: на микроконтроллере 1, с клавиатуры
          задаётся угол поворота сервопривода, по нажатию кнопки отправления
          данных, введённое с клавиатуры число передаётся на микроконтроллер 2,
          который устанавливает сервоприводу заданный угол.
        </p>
        <p>Вводимые цифры, должны выводиться на ЖКИ.</p>
        <p>Варианты:</p>
        <p>
          Использование портов UART оставить как в задании 4.1, но заменить
          метод получения на противоположный: то есть если был блокирующий, то
          сделать с прерыванием, а если был с прерыванием сделать блокирующий.
          Подключение сервомотора оставить как было сделано в задании 3.4.
        </p>
        <p>
          Схема может быть как на рисунке ниже. Была задействована клавиатура
          4х4, цифры соответствуют номерам на кнопках, на нажитие "on/c" сделано
          стирание последней введённой цифры, на кнопку "=" сделана отправка на
          микроконтроллер 2.
        </p>
        <p>
          Для тестирования передавать значение записываемое в регистр CCR
          таймера.
        </p>
        <p>
          Рекомендуется испльзовать библиотеку LCD, а не LCD2004, так как вывод
          на UART при каждом нажатии клавиши не нужен. Файлы библиотеки можно
          взять в Github репозитории курса, в папке Lib.
        </p>
        <p>
          Разница между этими библиотеками лишь в функции LCD_print, в
          библиотеке LCD не нужно указывать интерфейс UART при вызове функции.
        </p>
        <pre>
          LCD_print(resultBuffer); // вывод на ЖКИ в библиотеке LCD
          LCD_print(resultBuffer, huart1); // вывод на ЖКИ в библиотеке LDC2004
        </pre>
        <p>Ниже приведён пример схемы.</p>
        <div class="imageBlock">
          <img src="./images/module_4/4-2-1.png" />
          <p>Рисунок 8 Схема.</p>
        </div>
      </section>
      <section id="module4-3">
        <h3>Модуль 4.3. Калькулятор на двух микроконтроллерах</h3>
        <h4>Задание</h4>
        <p>
          С помощью клавиатуры калькулятора, подключенной к микроконтроллеру 1,
          вводятся числа в десятичном формате, по нажатию знака операции
          осуществляется передача числа с помощью 32-х портов, таким образом
          микроконтроллер 2 будет считывать 32-х разрядное число. Знак операции
          передаётся по UART. Микроконтроллер 2 выполняет арифметические
          операции с 32-х разрядными числами, результат выводится на ЖКИ. Для
          портов передачи использовать любые 32 порта, подключение UART и ЖКИ
          сохранить из предыдущих заданий. Для микроконтроллера 1 необходимо
          будет 32 выходных порта, а для микроконтроллера 2 32 входных порта.
        </p>
        <p>
          Также рекомендовано ограничить размер максимально вводимого
          десятичного числа девятью цифрами, для избежания случаев ввода чисел,
          разрядностью больше чем 32 бита.
        </p>
        <p>
          Так как порты микроконтроллера одной буквы 16-ти разрядные, то чтобы
          передать 32-х разрядное число необходимо задействовать порты двух
          букв.
        </p>
        <p>Пример подключения приведён на рисунке ниже.</p>
        <div class="imageBlock">
          <img src="./images/module_4/4-3-1.png" />
          <p>Рисунок 9 Схема.</p>
        </div>
        <p>
          Для передачи старших 16-ти разрядов используется порт PC, а для
          передачи младших порт PA.
        </p>
        <p>
          Так как микроконтроллер 32-х разрядный, то числа типа int будут 32-х
          разрядные, для передачи старших бит, потребуется наложить маску для
          старших 16-ти разрядов, и сдвинуть число на 16 разрядов вправо. Для
          передачи младших 16-ти бит накладывается маска для младших разрядов.
          Наложение маски необходимо чтобы передались нужные разряды числа, в
          противном случае, если число больше чем возможно поместить в 16
          разрядов, на на порт будет выведено максимально возможное 16-ти
          разрядное число, а не младшие 16 разрядов выводимого числа.
        </p>
        <p>
          Ниже приведён фрагмент кода для отправки 32-х разрядного числа. accum
          - это переменная, хранящая строковое представление числа, для вывода
          на ЖКИ. Чтобы записать число на порт используется команда GPIOX->ODR,
          X - буква нужного порта.
        </p>
        <pre>
          uint32_t high = 0b11111111111111110000000000000000;
	        uint32_t low = 0b00000000000000001111111111111111;
          GPIOC->ODR = (atoi(accum) & high) >> 16;
		      GPIOA->ODR = atoi(accum) & low;
        </pre>
        <p>
          Получать 32-х разрядное число можно аналогично, сдвинув на 16 разрядов
          значение порта, где ожидается получение старших разрядов . Чтобы
          получить значения порта необходимо использовать GPIOX->IDR, где X
          буква порта
        </p>
        <pre>
          uint16_t high = 0;
	        uint16_t low = 0;
          int32_t number = 0;
          high = GPIOC->IDR;
		      low = GPIOA->IDR;
          number = (high << 16) + low;
        </pre>
        <p>
          Для микроконтроллера 2 будет удобнее использовать библиотеку LCD2004,
          чтобы выводить на ЖКИ и одновременно отправлять числа на компорт для
          тестирования.
        </p>
        <p>
          На ЖКИ микроконтроллера 2 число должно обновляться после выполнения
          любой операции.
        </p>
      </section>
    </div>
  </body>
</html>
