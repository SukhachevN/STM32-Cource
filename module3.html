<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Методические указания.</title>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Модуль 3</h1>
        <h2>Содержание</h2>
        <nav>
          <ol>
            <li><a href="#introduction">Введение</a></li>
            <li>
              <a href="#module3-1">Генератор ШИМ</a>
            </li>
            <li>
              <a href="#module3-2">Работа с АЦП</a>
            </li>
            <li>
              <a href="#module3-3">Таймер с прерываниями</a>
            </li>
            <li>
              <a href="#module3-4">Управление углом сервомотора</a>
            </li>
          </ol>
        </nav>
      </header>
      <section id="introduction">
        <h2>Введение</h2>
        <section>
          <h3>Теоретическая часть</h3>
        </section>
      </section>
      <section id="module3-1">
        <h3>Модуль 3.1. Генератор ШИМ</h3>
        <h4>Задание</h4>
        <p>
          С помощью таймера 1 сгенерировать сигнал в соответсвии с вариантом
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Канал: 1, частота: 100Гц, скважность: 2</li>
          <li>Канал: 2, частота: 250Гц, скважность: 2</li>
          <li>Канал: 3, частота: 300Гц, скважность: 4</li>
          <li>Канал: 4, частота: 150Гц, скважность: 3</li>
          <li>Канал: 1, частота: 350Гц, скважность: 5</li>
          <li>Канал: 2, частота: 125Гц, скважность: 3</li>
          <li>Канал: 3, частота: 175Гц, скважность: 2</li>
          <li>Канал: 4, частота: 200Гц, скважность: 6</li>
          <li>Канал: 1, частота: 500Гц, скважность: 2</li>
          <li>Канал: 2, частота: 600Гц, скважность: 4</li>
          <li>Канал: 3, частота: 675Гц, скважность: 5</li>
          <li>Канал: 4, частота: 725Гц, скважность: 3</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>
          Создать проект, все действия по созданию проекта аналогичны предыдущим
          модулям, до этапа настроек.
        </p>
        <p>
          Включить тактирование. Далее перейти Timers > TIM1, в канале
          соответствующем варианту выбрать PWM Generation CHX, где X - номер
          канала по варианту.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-1.png" />
          <p>Рисунок 1 Настройка таймера</p>
        </div>
        <p>Далее перейти к разделу Parameter Setting > Counter Settings.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-3.png" />
          <p>Рисунок 2 Настройка таймера</p>
        </div>
        <p>Теперь необходимо разобраться о назначении каждого поля.</p>
        <p>
          Prescaler - предделитель системной частоты таймера. Предделитель это
          цифровой счётчик, который считает между тиками таймера. Если
          установить предделитель равным X, тогда между каждым тиком таймера,
          счётчик предделителя будет со скоростью системной частоты таймера
          отсчитывать от 0 до X и обнуляться. При каждом обнулении счётчика,
          таймер будет совершать очередной тик. Таким образом происходит деление
          частоты.
        </p>
        <p>
          Counter Mode - режим работы счётчика. Возможные варианты: UP, Down,
          Center Aligned Mode 1..3. UP - работа счетчика на прибавление, от 0 до
          X. Down - работа счетчика на вычитание, от X до 0. Center Aligned Mode
          - режим выравнивания по центру. В этом режиме счетчик считает от 0 до
          X, а затем считает в обратную сторону от X до 0.
        </p>
        <p>
          Для наглядности рассмотрен пример, когда значение переполнения
          счётчика задано 5.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-4.jpg" />
          <p>Рисунок 3 Выравнивание по краю</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-5.jpg" />
          <p>Рисунок 4 Выравнивание по центру</p>
        </div>
        <p>
          По рисунку видно, что длина и период импульса увеличиваются в 2 раза
          по сравнению с обычным режимом.
        </p>
        <p>
          Далее приведено объяснение различий между режимами 1, 2, 3. Разница в
          том, когда будет происходить прерывание, в случае если прерывание
          таймера было включено.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-6.jpg" />
          <p>Рисунок 5 Center Aligned mode 1</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-7.jpg" />
          <p>Рисунок 6 Center Aligned mode 2</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-8.jpg" />
          <p>Рисунок 7 Center Aligned mode 3</p>
        </div>
        <p>Counter Period — значение переполнения.</p>
        <p>
          Internal Clock Division - Делитель системной частоты таймера для
          формирования вспомогательного тактового сигнала, который используется
          в цифровых фильтрах, и для формирования времени запаздывания при
          работе в режиме PWM с комплементарными выходами (dead-time).
        </p>
        <p>
          Repetition Counter - количество переполнений для генерации прерывания.
          Если указать N, то прерывание будет вызываться на каждом N-ом
          переполнении.
        </p>
        <p>
          Repetition Counter - количество переполнений для генерации прерывания.
          Если указать N, то прерывание будет вызываться на каждом N-ом
          переполнении.
        </p>
        <p>
          auto-reload preload - необходимо для работы с дублирующими(буферным)
          регистрами таймера. Используется если в ходе работы изменяется
          значение переполнения.
        </p>
        <p>
          Теперь, после того, как стало понятно о назначении каждого поля, можно
          перейти к формуле: определяющей частоту генератора ШИМ.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-9.png" />
          <p>Рисунок 8 Формула для задания частоты</p>
        </div>
        <p>
          ARR - AutoReload Register, он же Counter Period. PSC - Prescaler.
          Clock - частота работы таймера. Почему к ARR и PSC прибавляется 1?
          Ответ: чтобы не было деления на 0.
        </p>
        <p>
          Из приведённой выше формулы, понятно, что задать частоту можно меняя
          значения clock, ARR, PSC. Чтобы не усложнять лабораторную работу
          настройкой частоты работы микроконтроллера, предполагается взять clock
          равным частоте работы микроконтроллера по умолчанию - 16Мгц.
        </p>
        <p>
          Далее рассмотрен пример генератора ШИМ 1000ГЦ(1кГц) со скважностью 2
          на первом канале таймера 1.
        </p>
        <p>
          F = 1000, Для удобства задания скважности и выполнения расчётов
          (ARR+1) = 1000 => ARR = 999. Пусть PSC+1 = X. Необходимо выразить
          подставить известные числа в формулу и выразить X.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-10.png" />
          <p>Рисунок 9 Вывод значения PSC</p>
        </div>
        <p>
          Итого для создания генератора ШИМ 1000ГЦ(1кГц) со скважностью 2
          необходимо указать следующие параметры:
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-2.png" />
          <p>Рисунок 10 Настройки счётчика таймера</p>
        </div>
        <p>
          Далее подключить UART для тестирования, сгенерировать код, включить
          создание hex-файла.
        </p>
        <p>
          Порт на котором будет выходной сигнал будет подсвечен зелёным цветом,
          после выбора канала таймера. Для 1-го канала это PA8, для 2-го PA9,
          для 3-го PA10, для 4-го PA11.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-11.png" />
          <p>Рисунок 11 Выходной порт генератора ШИМ</p>
        </div>
        <p>Генератор ШИМ включается следующей командой:</p>
        <pre>HAL_TIM_PWM_Start(&htimX, TIM_CHANNEL_Y);</pre>
        <p>
          &htimX - это указатель на таймер, X - номер таймера. TIM_CHANNEL_Y -
          указатель номера канала таймера, Y - номер канала. Так как по
          настройкам было задано создание на первом канале первого таймера, то
          код будет выглядеть следующим образом.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-12.png" />
          <p>Рисунок 12 Код генератора ШИМ</p>
        </div>
        <p>
          Скважность задаётся записью числа в регистр CCRX, где X номер канала.
          Значение в этом регистре определяет скважность сигнала. Это число
          до(либо после, это зависит от настроек счетчика) значения которого
          будет генерироваться сигнал. Так в данном примере счётчик считает от 0
          до 1000 (стоит помнить о прибавляемой 1 к заданному пределу счетчика),
          то для задания скважности 2 было установлено значение 500.
        </p>
        <p>
          Сгенерировать код, далее перейти к созданию проекта в среде Proteus.
        </p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          В среде Proteus поместить микроконтроллер, добавить
          осциллограф(OSCILLOSCOPE) и счётчик(COUNTER TIMER).Для этого выбрать
          соответствующий пункт в левом боковом меню.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-13.png" />
          <p>Рисунок 13 Подключение осциллографа и счётчика.</p>
        </div>
        <p>
          Осциллограф и счтчик подключить к порту-выходу генератора ШИМ, для
          этого примера это PA8.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-14.png" />
          <p>Рисунок 14 Подключение осциллографа и счётчика.</p>
        </div>
        <p>
          Счётчик понадобится для определения частоты, для этого необходимо
          поменять настройка. Правой кнопкой мыши кликнуть по счётчику, выбрать
          Edit Properties. Выполнить настройку в соответсвии с рисунком.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-15.png" />
          <p>Рисунок 15 Настройка счётчика.</p>
        </div>
        <p>
          Далее запустить проект, если окно с значениями осциллографа не
          появилось, вызвать его через меню.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-16.png" />
          <p>Рисунок 16 Вызов окна осциллографа.</p>
        </div>
        <p>Ожидается получение следующих результатов:</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-17.png" />
          <p>Рисунок 17 Результаты.</p>
        </div>
        <p>
          Как видно был получен сигнал со скважностью 2 и периодом 1мс, что
          соответствует частоте 1000Гц(1кГц). Значение на счётчике 1001(обычно в
          пределах 999-1001),считать это погрешностью среды Proteus, по
          осциллографу чётко видно период 1мс.
        </p>
        <p>
          Для демонстрации, далее скважность была изменена на 4. Для этого в
          коде были сделаны следующие изменения: в переменную PWM было записано
          значение 750, следовательно длительность импульса будет 250(1000-750)
          отсчётов счётчика.
        </p>
        <pre>int pwm = 750;</pre>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-18.png" />
          <p>Рисунок 18 Результат со скважностью 4.</p>
        </div>
        <p>Видно, что сигнал изменился, и скважность стала 4.</p>
        <p>
          Реализовать генератор ШИМ в соответствии с заданием варианта, для
          тестирования, на виртуальный порт отправлять данные в следующем
          формате:
        </p>
        <pre>
          char buffer[100];
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer,
                  sprintf(buffer, "%d<>%d<>%dEND", pwm, htim1.Init.Prescaler, htim1.Init.Period), 100);</pre
        >
        <p>
          * Задание повышенной сложности, реализовать генератор ШИП с переменной
          скважностью. Пример результата приведён ниже
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-19.png" />
          <p>Рисунок 19 Результат c переменной скважностью.</p>
        </div>
      </section>
      <section id="module3-2">
        <h3>Модуль 3.2. Работа с АЦП</h3>
        <h4>Задание</h4>
        <p>
          Рассмотреть пример использования АЦП. На основе примера реализовать
          программу считывающую значение температуры с датчика LM35 по нажатию
          кнопки, на заданном канале АЦП.
        </p>
        <p>
          * Задание повышенной сложности: сделать вывод значений температуры на
          ЖКИ.
        </p>
        <p>
          ** Задание повышенной сложности: сделать вывод отрицательной
          температуры.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Канал АЦП: 1, порт для кнопки: PB1</li>
          <li>Канал АЦП: 2, порт для кнопки: PD0</li>
          <li>Канал АЦП: 3, порт для кнопки: PE3</li>
          <li>Канал АЦП: 4, порт для кнопки: PC6</li>
          <li>Канал АЦП: 5, порт для кнопки: PС4</li>
          <li>Канал АЦП: 6, порт для кнопки: PE10</li>
          <li>Канал АЦП: 7, порт для кнопки: PA1</li>
          <li>Канал АЦП: 8, порт для кнопки: PD2</li>
          <li>Канал АЦП: 9, порт для кнопки: PA2</li>
          <li>Канал АЦП: 10, порт для кнопки: PB9</li>
          <li>Канал АЦП: 11, порт для кнопки: PC6</li>
          <li>Канал АЦП: 12, порт для кнопки: PA11</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект. Включить тактирование, подключить UART.</p>
        <p>
          Для включения АЦП, необходимо в меню ANALOG указать рабочий канал для
          АЦП.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-1.png" />
          <p>Рисунок 20 Включение АЦП.</p>
        </div>
        <p>
          После выбора канала, входной порт для АЦП будет подсвечен зелёным.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-2.png" />
          <p>Рисунок 21 входной порт АЦП.</p>
        </div>
        <p>Далее сгенерировать код. Включить создание hex-файла.</p>
        <p>
          Ниже приведён фрагмент кода для считывания значения датчика с АЦП.
        </p>
        <pre>
          HAL_ADC_Start(&hadc1); // запуск АЦП, как параметр передан указатель на АЦП.
          HAL_ADC_PollForConversion(&hadc1, 100); // Ожидание, пока АЦП преобразует значение, как параметры указатель на АЦП и время преобразования
          ADC_val = HAL_ADC_GetValue(&hadc1); // получение значения АЦП
          HAL_ADC_Stop(&hadc1); // остановка АЦП
          printTemp(ADC_val); // функция для обработки значения АЦП
          HAL_Delay(1000); // задержка 1 секунда
        </pre>
        <p>Функция преобразования значения АЦП:</p>
        <pre>
          void printTemp(uint16_t tmp) {
            uint32_t numVar = (tmp * 8.0586);
            char buffer[100];
            HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%.3d\n\r", numVar/100), 100);
          }
        </pre>
        <p>
          Почему входное значение функции умножается на 8.0586? Ответ: АЦП имеет
          разрядность 12 бит, 2^12 = 4096. 1 шаг АЦП будет (Vmax - Vmin)/(Число
          шагов - 1). Для выбранного микроконтроллера Vmax = 3.3В, Vmin = 0.
          Получается (3.3-0)/4095 = 8.0586. По информации из Datasheet LM35, 1
          градус = 10мВ, поэтому полученное значение необходимо разделить на
          100. Дробная часть в этом примере не обрабатывается.
        </p>
        <p>Скомпилировать код, перейти к созданию проекта в Proteus.</p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Поместить микроконтроллер. Для добавления датчика LM35, вызвать меню
          добавления элементов, в поисковой строке ввести "LM35".
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-3.png" />
          <p>Рисунок 22 Добавление датчика температуры.</p>
        </div>
        <p>
          Поместить все элементы на рабочем полем. Далее важным шагом для
          корректной работы АЦП является подключение питания к микроконтроллеру.
          Обычно система Proteus самостоятельно подключает питание, однако
          иногда этого не происходит. Без указания питания, АЦП всегда будет
          выдавать 0.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-4.png" />
          <p>Рисунок 23 Вид схемы.</p>
        </div>
        <p>
          Так как для выбранной модели микроконтроллера напряжение питания
          должно быть 3.3В, следует убедиться, что система Proteus назначила
          именно такое питание.
        </p>
        <p>Для этого в верхнем меню выбрать Design > Configure Power Rails.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-5.png" />
          <p>Рисунок 24 Настройка питания.</p>
        </div>
        <p>
          В поле Name выбрать VCC/VDD, при необходимости установить значение
          поля voltage = 3.3.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-6.png" />
          <p>Рисунок 25 Настройка питания.</p>
        </div>
        <p>
          Запустить проект. Если виртуальный терминал не появился, то вызвать
          его. Каждую секунду на виртуальный терминал будет выводиться текущее
          значение датчика.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-7.png" />
          <p>Рисунок 26 Результат.</p>
        </div>
        <p>
          В соответствии с вариантом сделать чтение АЦП на заданном канале, по
          нажатию кнопки.
        </p>
        <p>По завершению задания, выполнить тестирование.</p>
      </section>
      <section id="module3-3">
        <h3>Модуль 3.3. Таймер с прерыванием</h3>
        <h4>Задание</h4>
        <p>
          Рассмотреть пример работы таймера по прерыванию. Реализовать моргание
          светодиода по прерыванию на таймере и периодом в соответствии с
          вариантом.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Таймер: 2, период: 0.5 сек, порт светодиода: PA1</li>
          <li>Таймер: 3, период: 1.5 сек, порт светодиода: PB1</li>
          <li>Таймер: 4, период: 2 сек, порт светодиода: PC1</li>
          <li>Таймер: 5, период: 0.75 сек, порт светодиода: PD1</li>
          <li>Таймер: 2, период: 1.5 сек, порт светодиода: PE1</li>
          <li>Таймер: 3, период: 2.75 сек, порт светодиода: PA4</li>
          <li>Таймер: 4, период: 0.25 сек, порт светодиода: PC3</li>
          <li>Таймер: 5, период: 3 сек, порт светодиода: PD7</li>
          <li>Таймер: 2, период: 1.25 сек, порт светодиода: PB11</li>
          <li>Таймер: 3, период: 1.75 сек, порт светодиода: PE3</li>
          <li>Таймер: 4, период: 2.5 сек, порт светодиода: PC9</li>
          <li>Таймер: 5, период: 2.25 сек, порт светодиода: PA5</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект, включить тактирование, UART.</p>
        <p>
          Далее рассмотрен пример включения светодиода по прерыванию таймера 2 с
          периодом 1 сек.
        </p>
        <p>
          В разделе Timers выбрать таймер, в поле Clock Source указать Internal
          Source, это означает что будет выбран внутренний источник
          тактирования, для вариантов таймеров этого задания это будет шина
          APB2. По умолчанию частота этой шины 16Мгц.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-1.png" />
          <p>Рисунок 27 Настройки таймера.</p>
        </div>
        <p>
          Принцип задания Preascaler и Counter Period точно такой же как в
          задании 3.1.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-9.png" />
          <p>Рисунок 28 Формула задания частоты таймера.</p>
        </div>
        <p>
          Однако стоит помнить, что светодиод также надо выключать, поэтому
          получается, что необходимо будет задать частоту в два раза больше.
          Поэтому значение Counter Period 4999, а не 9999.
        </p>
        <p>Как порт для светодиода был выбран PA1</p>
        <p>Сгенерировать код, включить генерацию hex-файла.</p>
        <p>
          Для включения таймера с прерыванием, необходимо перед циклом while
          написать следующий код.
        </p>
        <pre>
          HAL_TIM_Base_Start_IT(&htim2);
        </pre>
        <p>Обработка прерывания задаётся в файле stm32f4xx_it.c</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-2.png" />
          <p>Рисунок 29 файл для обработки прерывания.</p>
        </div>
        <p>
          В этом файле найти функцию обработки прерывания, так как для примера
          был выбран таймер 2, то название функции TIM2_IRQHandler
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-3.png" />
          <p>Рисунок 30 функция обработки прерывания.</p>
        </div>
        <p>
          Для переключения светодиода в теле функции было указано следующее:
        </p>
        <pre>
          HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1 );
        </pre>
        <p>Эта функция переключает значение порта на противоположное.</p>
        <p>Скомпилировать код, далее перейти к созданию проекта в Proteus.</p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Поместить микроконтроллер, для добавления светодиода ввести в
          помсковой строке "LED", далее выбрать светодиод любого цвета.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-4.png" />
          <p>Рисунок 31 добавление светодиода.</p>
        </div>
        <p>
          Так как симуляции может сильно нагружать рабочий компьютер, то скорее
          всего появится следующее предупреждение, о том, что анимация будет
          происходить с задержкой.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-5.png" />
          <p>Рисунок 32 Предупреждение.</p>
        </div>
        <p>
          В таком случае, визуально будет казаться, что светодиод моргает
          значительно реже, чем 1 раз в секунду, однако в том, что период 1
          секунда, можно убедиться подключив осциллограф.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-6.png" />
          <p>Рисунок 33 Результат.</p>
        </div>
        <p>По осциллографу видно, что светодиод включается каждую секунду.</p>
        <p>
          * Задание повышенной сложности: реализовать прерывания с несколькими
          таймерами с разным периодом.
        </p>
        <p>
          Для тестирования выводить Prescaler и Counter Period в следующем
          формате:
        </p>
        <pre>
          char buffer[100];
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer,
                  sprintf(buffer, "%d<>%dEND", htim2.Init.Prescaler, htim2.Init.Period), 100);</pre
        >
      </section>
      <section id="module3-4">
        <h3>Модуль 3.4. Управление углом сервомотора</h3>
        <h4>Задание</h4>
        <p>
          Доработать программу пример, чтобы с помощью потенциометра задавался
          угол сервомотора. Сделать вывод угла поворота на виртуальный терминал
          по нажатию кнопки.
        </p>
        <p>
          * Задание повышенной сложности: сделать вывод значения угла поворота
          на ЖКИ.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Таймер: 1, канал таймера: 2, канал АЦП: 1</li>
          <li>Таймер: 2, канал таймера: 1, канал АЦП: 2</li>
          <li>Таймер: 3, канал таймера: 2, канал АЦП: 3</li>
          <li>Таймер: 4, канал таймера: 3, канал АЦП: 4</li>
          <li>Таймер: 5, канал таймера: 4, канал АЦП: 5</li>
          <li>Таймер: 1, канал таймера: 2, канал АЦП: 6</li>
          <li>Таймер: 2, канал таймера: 1, канал АЦП: 7</li>
          <li>Таймер: 3, канал таймера: 3, канал АЦП: 8</li>
          <li>Таймер: 4, канал таймера: 4, канал АЦП: 9</li>
          <li>Таймер: 5, канал таймера: 2, канал АЦП: 10</li>
          <li>Таймер: 1, канал таймера: 3, канал АЦП: 11</li>
          <li>Таймер: 2, канал таймера: 4, канал АЦП: 12</li>
        </ol>
        <p>
          Порт для кнопки подобрать самостоятельно. В случае конфликтов
          назначения портов, выбрать назначение конфликтного порта
          самостоятельно.
        </p>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект, включить тактирование, UART.</p>
        <p>
          Для примера будет рассмотрено использование 1-го канала таймера 1 и
          0-го канала АЦП.
        </p>
        <p>
          Указать канал АЦП, указать в заданном канале таймера значение PWM
          Generation CHX, где X - номер канала, остальные параметры таймера
          оставить по умолчанию.
        </p>
        <p>Сгенерировать код.</p>
        <p>Подключить библиотеку math</p>
        <pre>
          #include "math.h"
        </pre>
        <p>Перед циклом while добавить следующий код:</p>
        <pre>
          HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1); // запуск генератора ШИМ
          TIM1->CR1 &= 0xFFFE; // выключить выход таймера
          TIM1->PSC = 15; 
          TIM1->ARR = 19999;
          TIM1->CCR1 = 18500;
          TIM1->CR1 |= 0x1; // включить выход таймера
        </pre>
        <p>
          Для работы сервопривода требуется сигнал частотой 50Гц(20мс),
          длительностью сигнала задаётся угол поворота сервомотора, 1мс = -90
          градусов, 1.5мс = 0 градусов, 2мс = 90 градусов. Длительность сигнала
          обязательно должна быть в пределах от 1 до 2 мс. По формуле известной
          из задания 3.1 задаются значения PSC и ARR. ARR выбрано 19999, чтобы
          было удобнее задавать длительность сигнала. В регистр CCR1 записано
          значение 18500, что соответствет длительности сигнала 1.5мс и углу 0
          градусов.
        </p>
        <p>В цикле while добавить:</p>
        <pre>
          HAL_ADC_Start(&hadc1);
          HAL_ADC_PollForConversion(&hadc1, 100);
          ADC_val = HAL_ADC_GetValue(&hadc1);
          HAL_ADC_Stop(&hadc1);
          setServo(ADC_val);
        </pre>
        <p>Функция setServo:</p>
        <pre>
          uint32_t last;
          void setServo(uint16_t tmp) {
            double value = tmp;
            if (last != tmp) {
              last=tm
              TIM1->CR1 &= 0xFFFE;
             // TIM1->CCR1 = (int) value; 
              TIM1->CR1 |= 0x1;
            }
          }
        </pre>
        <p>
          Необходимо разобраться, какие преобразования нужно сделать чтобы
          задавать угол поворота сервопривода, с помощью потенциометра.
          Преобразовать значение потенциометра в значения угла поворота(диапазон
          от 0 до 180, значение сервомотора 90 считать 0, 0 градусов считать 90,
          -90 считать 180 и так далее).
        </p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Для добавления сервомотора в поисковой строке ввести MOTOR-PWMSERVO.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-4.png" />
          <p>Рисунок 35 Добавление сервопривода.</p>
        </div>
        <p>Для добавления потенциометра в поисковой строке ввести POT-HG.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-5.png" />
          <p>Рисунок 36 Добавление потенциометра.</p>
        </div>
        <p>Пример подключения приведён ниже, в примерах работы программы.</p>
        <p>Примеры работы программы</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-1.png" />
          <p>Рисунок 34 Результат.</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-2.png" />
          <p>Рисунок 35 Результат.</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-3.png" />
          <p>Рисунок 36 Результат.</p>
        </div>
      </section>
    </div>
  </body>
</html>
