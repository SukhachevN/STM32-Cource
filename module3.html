<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Методические указания.</title>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Модуль 3</h1>
        <h2>Содержание</h2>
        <nav>
          <ol>
            <li><a href="#introduction">Введение</a></li>
            <li>
              <a href="#module3-1">Генератор ШИМ</a>
            </li>
            <li>
              <a href="#module3-2">Работа с АЦП</a>
            </li>
            <li>
              <a href="#module3-3">Таймер с прерываниями</a>
            </li>
            <li>
              <a href="#module3-4">Управление углом сервомотора</a>
            </li>
          </ol>
        </nav>
      </header>
      <section id="introduction">
        <h2>Введение</h2>
        <section>
          <h3>Теоретическая часть</h3>
          <h4>Таймеры в STM32</h4>
          <p>
            В микроконтроллерах фирмы STM, у 32-х разрядных микроконтроллеров
            все таймеры можно выделить следующие типы таймеров:
          </p>
          <ul>
            <li>Расширенные (TIM1, TIM8, TIM20)</li>
            <li>Общего назначения (TIM2,TIM3,TIM4,TIM5)</li>
            <li>Базовые (все остальные таймеры)</li>
          </ul>
          <p>
            Стоить отметить, что у компании STM есть своя система именования
            таймеров, поэтому нумерация таймеров не последовательная, то есть
            наличие таймера TIM20 не означает, что у микроконтроллера есть 19
            других таймеров, цифра означает лишь принадлежность к типу. Таймеры
            с одинаковой цифрой в названии одинаковы на разных моделях
            микроконтроллеров.
          </p>
          <p>
            Самыми продвинутыми, и имеющими наибольший функционал являются
            расширенные таймеры. Все остальные можно рассматривать как
            ограниченные версии расширенных. Обычно каждый микроконтроллер STM
            имеет хотя бы один расширенный таймер, это TIM1.
          </p>
          <p>На рисунке ниже приведена структурная схема таймера 1.</p>
          <div class="imageBlock">
            <img src="./images/module_3/t-1.png" />
            <p>Рисунок 1 Структурная схема таймера 1</p>
          </div>
          <p>Эту же схему можно изобразить в упрощённом виде:</p>
          <div class="imageBlock">
            <img src="./images/module_3/t-2.png" />
            <p>Рисунок 2 упрощённая структурная схема таймера</p>
          </div>
          <p>Можно выделить следующие основные блоки:</p>
          <ul>
            <li>Блок задания времени (Time-base unit)</li>
            <li>Блок управления (Controller)</li>
            <li>Каналы таймера (Channels)</li>
            <li>Блок защитного отключения выходов каналов (Break)</li>
          </ul>
          <p>Связи между блоками указаны стрелками на схеме.</p>
          <p>
            С таймером можно взаимодействовать извне, для этого имеются
            специальные входы и выходы это ETR и BKIN. Также некоторые таймеры
            предусматривают возможность взаимодействия друг с другом. Для этого
            имеется по одному внутреннему выходу для сигнала-триггера (TRGO) и
            по четыре внутренних входа для сигналов-триггеров ITR0, ITR1, ITR2,
            ITR3. Каждый вход для сигнала триггера таймера подключён к выходу
            сигнала триггера другого таймера, с которым предполагается
            взаимодействие. Выход сигнала триггера, также может быть подключен
            ко входам сигналов триггеров других таймеров. Режим в котором будут
            использоваться входs и выходы сигналов-триггеров таймеров зависит от
            задаваемых настроек.
          </p>
          <p>
            Главным считается блок задания времени, его главный элемент -
            счётчик. Обычно счётчики универсальных таймеров в STM32 имеют
            разрядность 16 бит, однако в некоторых моделях таймеры TIM2 и TIM5
            имеют разрядность 32 бита. Работа счётчика идёт в паре с регистром
            автоматической перезагрузки, который управляет пересчётом. Данный
            регистр определяет до или от какого значения будет выполняться счёт,
            по достижению значения которого, либо нуля если счёт был обратный,
            происходит переполнение и сброс счётчика. Событие переполнения
            вызывает формирование специального сигнала, по которому происходит
            выполнение различных действий, в том числе и формирование
            прерывания. Счётчик тактируется сигналом, который поступает через
            предделитель с задаваемым коэффициентом, этот коэффициент можно
            задавать в пределах от 1 до 65535, он построен на основе 16-ти
            разрядного счётчика. На предделитель сигнал поступает из схемы
            управления.
          </p>
          <p>
            Для блока управления имеется возможность выбора источника
            тактирующего сигнала, выбирать можно из: внутреннего тактового
            сигнала шины, внешнего сигнала ETR, сигнала энкодер интерфейса. Блок
            управления задаёт режим счёта : UP, DOWN, Center Aligned, однако для
            выбора режима счёта таймер должен уметь переключать режимы, что
            иногда недоступно для простых таймеров. Направление счёта обычно
            задаётся с помощью специальных битов конфигурации, однако в режиме
            Center Aligned направление зависит от текущего состояния таймера,
            подробнее о режиме center aligned написано в практической части, в
            разделе настройки таймера. Блок управления генерирует выходной
            сигнал-триггер, этот сигнал может формироваться как при переполнении
            счётчика таймера, так и при других событиях, это зависит от настроек
            таймера.
          </p>
          <p>
            Блоки управления и задания времени обязательны и входят в любой
            таймер в микроконтроллерах STM32. С помощью использования разных
            каналов таймера, можно существенно расширить функционал. На каналах
            таймеров можно выполнять такие практические задачи как генерация
            импульсных сигналов, так и измерение параметров других импульсных
            сигналов. Каналы могут работать, как и в режиме входа, так и в
            режиме выхода. Все действия, могут выполняться и программно, но
            аппаратное выполнение разгружает процессор, увеличивая
            быстродействие.
          </p>
          <p>
            Если канал работает в режиме входа, то он может сохранять текущее
            состояние счётчика таймера в регистр в случае получения
            сигнала-триггера. С помощью настроек возможно задание источника
            сигнала и выбор события, для сохранения значения: фронт или спад. По
            значению счётчика таймера, записанному в регистр, возможно
            определить время, когда произошло событие, вызвавшее запись в
            регистр. Всё это также можно выполнить программно, но это влечёт
            большую нагрузку на процессор.
          </p>
          <p>
            Генерация сигналов происходит, когда канал находится в выходном
            режиме. Для генерации сигнала в регистр должно быть записано
            определённое значение. На каждом такте работы, происходит сравнение
            текущего значения счётчика таймера, и того числа, что записано в
            регистр. Выходной сигнал зависит от результата этого сравнения и от
            настроек таймера. Например, если значения совпали, то могут
            происходить следующие действия: формирование сигнала
            высокого/низкого уровня, смена текущего уровня сигнала на
            противоположный по значению. Кроме того, канал может иметь не только
            один, но и два выхода, сигналы на которых изменяются в противофазе,
            с возможностью задания полярности активных уровней сигналов и
            времени задержек между сигналами при их переключения. Возможна
            программная реализация, но ценой большой на-грузки на процессор.
          </p>
          <h4>АЦП</h4>
          <p>АЦП в STM32 обладает следующими особенностями:</p>
          <ul>
            <li>Разрядность 12 бит.</li>
            <li>Опорное напряжение от 2.4 до 3.6 Вольта.</li>
            <li>Скорость оцифровки до 1MSPS.</li>
            <li>
              18 каналов (16 внешних и 2 внутренних – для опорного напряжения и
              температурного датчика).
            </li>
            <li>
              Прерывание по окончании регулярных и инжектированных
              преобразований.
            </li>
            <li>Прерывание от оконного компаратора(Analog watchdog).</li>
            <li>Отправка данных по DMA для регулярных преобразований.</li>
            <li>Одиночное и непрерывное преобразование.</li>
            <li>Режим сканирования каналов по заданному списку.</li>
            <li>Выравнивание результата по выбранному краю.</li>
          </ul>
          <p>
            АЦП измеряет аналоговый сигнал с определённой частотой,
            следовательно, чем выше частота, тем точнее будет считываться
            измеряемый сигнал, с которым сможет работать микроконтроллер.
          </p>
          <p>
            Режим регулярных преобразований. В данном режиме работы необходимо
            задать группу от 1 до 16 каналов, для которых будет происходить
            последовательная обработка, однако результат будет помещается в один
            12-разрядный регистр, то есть новый результат будет перезатирать
            старый, поэтому после каждого преобразования, необходимо сохранять
            полученное значение. Преобразования могут быть как периодичными, так
            и происходить циклично, запуск может быть по таймеру или по внешнему
            прерыванию.
          </p>
          <p>
            Режим инжектированных преобразований. В данном режиме задётся группа
            от 1 до 4 каналов, каждый из этих каналов имеет свой собственный
            регистр, чтобы хранить результат. В случае запуска инжектированных
            преобразований, происходит приостановление регулярных
            преобразований, до того момента пока не завершатся инжектированные
            преобразования.
          </p>
          <p>
            Оконный компаратор. Функция данного устройства - это генерация
            прерывания, в том случае, если результат преобразования вышел за
            пределы границ, заданных пользователем, они же условия превышения и
            снижения напряжения. Оконный компаратор может использоваться для
            отслеживания состояния как одного выбранного регулярного или
            инжектированного канала, так и всех регулярных или инжектированных
            каналов. Помимо отслеживания уровня напряжения, можно использовать
            оконный компаратор для определения пересечения нуля.
          </p>
          <div class="imageBlock">
            <img src="./images/module_3/t-3.png" />
            <p>Рисунок 3 Схема АЦП</p>
          </div>
          <h4>LM35</h4>
          <p>
            В лабораторной работе для задания на работу с АЦП используется
            датчик температуры LM35.
          </p>
          <p>
            Серия LM35 представляет собой интегральные датчики температуры,
            выходное напряжение которых пропорционально температуре по шкале
            Цельсия. Это одно из преимуществ над датчиками с выходным
            напряжением по шкале Кельвина, так как не требуется делать лишних
            преобразований, в большинстве случаев.
          </p>
          <p>
            LM35 может работать с точностью ±0.75 °C в полном диапазоне рабочих
            температур -55 … +150 °C, без внешней калибровки или подгонки
            выходного напряжения.
          </p>
          <p>У датчиков серии LM35 можно выделить следующие особенности:</p>
          <ul>
            <li>Значение температуры пропорционально шкале Цельсия.</li>
            <li>Значение напряжения 10 мВ на градус Цельсия.</li>
            <li>Гарантирована точность 0.5 °C (при 25 °C).</li>
            <li>
              Параметры нормированы для полного диапазона температур -55 … +150
              °C.
            </li>
            <li>
              Удобны для использования в устройствах с удаленным подключением
              датчиков.
            </li>
            <li>Низкая цена.</li>
            <li>Потребляемый ток менее 60 мкА.</li>
            <li>
              Низкое выходное сопротивление – 0.1 Ом, при токе нагрузки 1 мА.
            </li>
            <li>
              Низкий уровень собственного разогрева – 0.08 °C при неподвижном
              воздухе.
            </li>
          </ul>
          <div class="imageBlock">
            <img src="./images/module_3/t-4.png" />
            <p>Рисунок 4 структурная схема LM35</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_3/t-5.png" />
            <p>Рисунок 5 размеры LM35</p>
          </div>
          <h4>Сервомотор</h4>
          <p>
            Сервомотор – это механический привод, способный регулировать свой
            угол поворота. Сервомоторы применяются в областях, с точным
            контролем. Как пример это робототехника, автоматизированные станки,
            авиамоделирование и так далее. Также используются и в других
            областях.
          </p>
          <p>
            Важной особенностью сервомотора, является отсутствие возможности
            полного вращения на 360 градусов, поэтому они не применяются в
            областях, где необходимо непрерывное вращение двигателя. Стандартно
            сервомотор может вращаться не более чем на 180 градусов, обычно
            указывают диапазон поворота 0-180 градусов или от -90 до +90.
          </p>
          <p>
            Сервопривод состоит из электродвигателя постоянного тока, который
            приводит в действие редуктор. Редуктор уменьшая скорость вращения
            двигателя одновременно увеличивает крутящий момент на валу. Чтобы
            контролировать положение выходного вала, редуктор соединён с
            датчиком положения, в общем случае это потенциометр. Для управления
            мощностью и направлением электродвигателя, схема управления
            использует входной сигнал от датчика положения и сигнал управления,
            который задаёт нужное положение сервопривода.
          </p>
          <div class="imageBlock">
            <img src="./images/module_3/t-6.png" />
            <p>Рисунок 6 устройство сервопривода</p>
          </div>
          <p>
            Схема управления, по получению с помощью сигнала управления
            необходимое положение вала, производит вычитание из него значения
            текущего положения его положения вала, после чего вырабатывает
            «сигнал ошибки», который может быть как положительным, так и
            отрицательным. Этот «сигнал ошибки» далее передаётся на питание
            электродвигателя, тем самым изменяя положение вала на нужное. В
            зависимости от разницы между текущим и заданным положениями, будет
            зависеть скорость поворота вала. Чем больше, тем быстрее.
          </p>
          <p>
            Управляющий сигнал серводвигателя – это ШИМ сигнал. Вид данного
            сигнала представлен на рисунке ниже.
          </p>
          <div class="imageBlock">
            <img src="./images/module_3/t-7.png" />
            <p>Рисунок 7 сигнал управления сервопривода</p>
          </div>
        </section>
      </section>
      <section id="module3-1">
        <h3>Модуль 3.1. Генератор ШИМ</h3>
        <h4>Задание</h4>
        <p>
          С помощью таймера 1 сгенерировать сигнал в соответствии с вариантом.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Канал: 1, частота: 100Гц, скважность: 2</li>
          <li>Канал: 2, частота: 250Гц, скважность: 2</li>
          <li>Канал: 3, частота: 300Гц, скважность: 4</li>
          <li>Канал: 4, частота: 150Гц, скважность: 3</li>
          <li>Канал: 1, частота: 350Гц, скважность: 5</li>
          <li>Канал: 2, частота: 125Гц, скважность: 3</li>
          <li>Канал: 3, частота: 175Гц, скважность: 2</li>
          <li>Канал: 4, частота: 200Гц, скважность: 6</li>
          <li>Канал: 1, частота: 500Гц, скважность: 2</li>
          <li>Канал: 2, частота: 600Гц, скважность: 4</li>
          <li>Канал: 3, частота: 675Гц, скважность: 5</li>
          <li>Канал: 4, частота: 725Гц, скважность: 3</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>
          Создать проект, все действия по созданию проекта аналогичны предыдущим
          модулям, до этапа настроек.
        </p>
        <p>
          Включить тактирование. Далее перейти Timers > TIM1, в канале
          соответствующем варианту выбрать PWM Generation CHX, где X - номер
          канала по варианту.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-1.png" />
          <p>Рисунок 8 Настройка таймера</p>
        </div>
        <p>Далее перейти к разделу Parameter Setting > Counter Settings.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-3.png" />
          <p>Рисунок 9 Настройка таймера</p>
        </div>
        <p>Теперь необходимо разобраться о назначении каждого поля.</p>
        <p>
          Prescaler - предделитель системной частоты таймера. Предделитель это
          цифровой счётчик, который считает между тиками таймера. Если
          установить предделитель равным X, тогда между каждым тиком таймера,
          счётчик предделителя будет со скоростью системной частоты таймера
          отсчитывать от 0 до X и обнуляться. При каждом обнулении счётчика,
          таймер будет совершать очередной тик. Таким образом происходит деление
          частоты.
        </p>
        <p>
          Counter Mode - режим работы счётчика. Возможные варианты: UP, Down,
          Center Aligned Mode 1..3. UP - работа счетчика на прибавление, от 0 до
          X. Down - работа счетчика на вычитание, от X до 0. Center Aligned Mode
          - режим выравнивания по центру. В этом режиме счетчик считает от 0 до
          X, а затем считает в обратную сторону от X до 0.
        </p>
        <p>
          Для наглядности рассмотрен пример, когда значение переполнения
          счётчика задано 5.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-4.jpg" />
          <p>Рисунок 10 Выравнивание по краю</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-5.jpg" />
          <p>Рисунок 11 Выравнивание по центру</p>
        </div>
        <p>
          По рисунку видно, что длина и период импульса увеличиваются в 2 раза
          по сравнению с обычным режимом.
        </p>
        <p>
          Далее приведены изображения, показывающие различия между режимами 1,
          2, 3. Разница в том, когда будет происходить прерывание, при условии
          если прерывание было включено.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-6.jpg" />
          <p>Рисунок 12 Center Aligned mode 1</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-7.jpg" />
          <p>Рисунок 13 Center Aligned mode 2</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-8.jpg" />
          <p>Рисунок 14 Center Aligned mode 3</p>
        </div>
        <p>Counter Period — значение переполнения.</p>
        <p>
          Internal Clock Division - Делитель системной частоты таймера для
          формирования вспомогательного тактового сигнала, который используется
          в цифровых фильтрах, и для формирования времени запаздывания при
          работе в режиме PWM с комплементарными выходами (dead-time).
        </p>
        <p>
          Repetition Counter - количество переполнений для генерации прерывания.
          Если указать N, то прерывание будет вызываться на каждом N-ом
          переполнении.
        </p>
        <p>
          Auto-reload preload - необходимо для работы с дублирующими(буферным)
          регистрами таймера. Используется если в ходе работы изменяется
          значение переполнения.
        </p>
        <p>
          Теперь, после того, как стало понятно о назначении каждого поля, можно
          перейти к формуле: определяющей частоту генератора ШИМ.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-9.png" />
          <p>Рисунок 15 Формула для задания частоты</p>
        </div>
        <p>
          ARR - AutoReload Register, он же Counter Period. PSC - Prescaler.
          Clock - частота работы таймера. Почему к ARR и PSC прибавляется 1?
          Ответ: чтобы никогда не было деления на 0.
        </p>
        <p>
          Из приведённой выше формулы, понятно, что задать частоту можно меняя
          значения clock, ARR, PSC. Чтобы не усложнять лабораторную работу
          настройкой частоты работы микроконтроллера, предполагается взять clock
          равным частоте работы микроконтроллера по умолчанию - 16МГц.
        </p>
        <p>
          Далее рассмотрен пример генератора ШИМ 1000Гц(1кГц) со скважностью 2
          на первом канале таймера 1.
        </p>
        <p>
          F = 1000, Для удобства задания скважности и выполнения расчётов
          (ARR+1) = 1000 => ARR = 999. Пусть PSC+1 = X. Необходимо выразить
          подставить известные числа в формулу и выразить X.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-10.png" />
          <p>Рисунок 16 Вывод значения PSC</p>
        </div>
        <p>
          Итого для создания генератора ШИМ 1000Гц(1кГц) со скважностью 2
          необходимо указать следующие параметры:
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-2.png" />
          <p>Рисунок 17 Настройки счётчика таймера</p>
        </div>
        <p>
          Далее подключить UART для тестирования, сгенерировать код, включить
          создание hex-файла.
        </p>
        <p>
          Порт на котором будет выходной сигнал будет подсвечен зелёным цветом,
          после выбора канала таймера. Для 1-го канала это PA8, для 2-го PA9,
          для 3-го PA10, для 4-го PA11.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-11.png" />
          <p>Рисунок 18 Выходной порт генератора ШИМ</p>
        </div>
        <p>Генератор ШИМ включается следующей командой:</p>
        <pre>HAL_TIM_PWM_Start(&htimX, TIM_CHANNEL_Y);</pre>
        <p>
          &htimX - это указатель на таймер, X - номер таймера. TIM_CHANNEL_Y -
          указатель номера канала таймера, Y - номер канала. Так как по
          настройкам было задано создание на первом канале первого таймера, то
          код будет выглядеть следующим образом.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-12.png" />
          <p>Рисунок 19 Код генератора ШИМ</p>
        </div>
        <p>
          Скважность задаётся записью числа в регистр CCRX, где X номер канала.
          Значение в этом регистре определяет скважность сигнала. Это число
          до(либо после, это зависит от настроек счетчика) значения которого
          будет генерироваться сигнал. Так в данном примере счётчик считает от 0
          до 1000 (стоит помнить о прибавляемой 1 к заданному пределу счетчика),
          то для задания скважности 2 было установлено значение 500.
        </p>
        <p>
          Сгенерировать код, далее перейти к созданию проекта в среде Proteus.
        </p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          В среде Proteus поместить микроконтроллер, добавить
          осциллограф(OSCILLOSCOPE) и счётчик(COUNTER TIMER).Для этого выбрать
          соответствующий пункт в левом боковом меню.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-13.png" />
          <p>Рисунок 20 Подключение осциллографа и счётчика.</p>
        </div>
        <p>
          Осциллограф и счтчик подключить к порту-выходу генератора ШИМ, для
          этого примера это PA8.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-14.png" />
          <p>Рисунок 21 Подключение осциллографа и счётчика.</p>
        </div>
        <p>
          Счётчик понадобится для определения частоты, для этого необходимо
          поменять настройка. Правой кнопкой мыши кликнуть по счётчику, выбрать
          Edit Properties. Выполнить настройку в соответсвии с рисунком.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-15.png" />
          <p>Рисунок 22 Настройка счётчика.</p>
        </div>
        <p>
          Далее запустить проект, если окно с значениями осциллографа не
          появилось, вызвать его через меню.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-16.png" />
          <p>Рисунок 23 Вызов окна осциллографа.</p>
        </div>
        <p>Ожидается получение следующих результатов:</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-17.png" />
          <p>Рисунок 24 Результаты.</p>
        </div>
        <p>
          Как видно был получен сигнал со скважностью 2 и периодом 1мс, что
          соответствует частоте 1000Гц(1кГц). Значение на счётчике 1001(обычно в
          пределах 999-1001), можно считать погрешностью среды Proteus, по
          осциллографу чётко видно период 1мс.
        </p>
        <p>
          Для демонстрации, скважность была изменена на 4. Для этого в коде были
          сделаны следующие изменения: в переменную PWM было записано значение
          750, следовательно длительность импульса будет 250(1000-750) отсчётов
          счётчика.
        </p>
        <pre>int pwm = 750;</pre>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-18.png" />
          <p>Рисунок 25 Результат со скважностью 4.</p>
        </div>
        <p>Видно, что сигнал изменился, и скважность стала 4.</p>
        <p>
          Реализовать генератор ШИМ в соответствии с заданием варианта, для
          тестирования, на виртуальный порт отправлять данные в следующем
          формате:
        </p>
        <pre>
          char buffer[100];
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer,
                  sprintf(buffer, "%d<>%d<>%dEND", pwm, htim1.Init.Prescaler, htim1.Init.Period), 100);</pre
        >
        <p>
          * Задание повышенной сложности, реализовать генератор ШИМ с переменной
          скважностью. Пример результата приведён ниже
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-19.png" />
          <p>Рисунок 26 Результат c переменной скважностью.</p>
        </div>
      </section>
      <section id="module3-2">
        <h3>Модуль 3.2. Работа с АЦП</h3>
        <h4>Задание</h4>
        <p>
          Рассмотреть пример использования АЦП. На основе примера реализовать
          программу считывающую значение температуры с датчика LM35 по нажатию
          кнопки, на заданном канале АЦП.
        </p>
        <p>
          * Задание повышенной сложности: сделать вывод значений температуры на
          ЖКИ.
        </p>
        <p>
          * Задание повышенной сложности: взять любой другой датчик температуры,
          и считать его значение.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Канал АЦП: 1, порт для кнопки: PB1</li>
          <li>Канал АЦП: 2, порт для кнопки: PD0</li>
          <li>Канал АЦП: 3, порт для кнопки: PE3</li>
          <li>Канал АЦП: 4, порт для кнопки: PC6</li>
          <li>Канал АЦП: 5, порт для кнопки: PС4</li>
          <li>Канал АЦП: 6, порт для кнопки: PE10</li>
          <li>Канал АЦП: 7, порт для кнопки: PA1</li>
          <li>Канал АЦП: 8, порт для кнопки: PD2</li>
          <li>Канал АЦП: 9, порт для кнопки: PA2</li>
          <li>Канал АЦП: 10, порт для кнопки: PB9</li>
          <li>Канал АЦП: 11, порт для кнопки: PC6</li>
          <li>Канал АЦП: 12, порт для кнопки: PA11</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект. Включить тактирование, подключить UART.</p>
        <p>
          Для включения АЦП, необходимо в меню ANALOG указать рабочий канал для
          АЦП. Остальные настройки оставить как есть.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-1.png" />
          <p>Рисунок 27 Включение АЦП.</p>
        </div>
        <p>
          После выбора канала, входной порт для АЦП будет подсвечен зелёным.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-2.png" />
          <p>Рисунок 28 входной порт АЦП.</p>
        </div>
        <p>Далее сгенерировать код. Включить создание hex-файла.</p>
        <p>
          Ниже приведён фрагмент кода для считывания значения датчика с АЦП.
        </p>
        <pre>
          HAL_ADC_Start(&hadc1); // запуск АЦП, как параметр передан указатель на АЦП.
          HAL_ADC_PollForConversion(&hadc1, 100); // Ожидание, пока АЦП преобразует значение, как параметры указатель на АЦП и время преобразования
          ADC_val = HAL_ADC_GetValue(&hadc1); // получение значения АЦП
          HAL_ADC_Stop(&hadc1); // остановка АЦП
          printTemp(ADC_val); // функция для обработки значения АЦП
          HAL_Delay(1000); // задержка 1 секунда
        </pre>
        <p>Функция преобразования значения АЦП:</p>
        <pre>
          void printTemp(uint16_t tmp) {
            uint32_t numVar = (tmp * 8.0586);
            char buffer[100];
            HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%.3d\n\r", numVar/100), 100);
          }
        </pre>
        <p>
          Почему входное значение функции умножается на 8.0586? Ответ: АЦП имеет
          разрядность 12 бит, 2^12 = 4096. 1 шаг АЦП будет (Vmax - Vmin)/(Число
          шагов - 1). Для выбранного микроконтроллера Vmax = 3.3В, Vmin = 0.
          Получается (3.3-0)/4095 = 8.0586. По информации из Datasheet LM35, 1
          градус = 10мВ, поэтому полученное значение необходимо разделить на
          100. Дробная часть в этом примере не обрабатывается.
        </p>
        <p>Скомпилировать код, перейти к созданию проекта в Proteus.</p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Поместить микроконтроллер. Для добавления датчика LM35, вызвать меню
          добавления элементов, в поисковой строке ввести "LM35".
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-3.png" />
          <p>Рисунок 29 Добавление датчика температуры.</p>
        </div>
        <p>
          Поместить все элементы на рабочем полем. Далее важным шагом для
          корректной работы АЦП является подключение питания к микроконтроллеру.
          Обычно система Proteus самостоятельно подключает питание, однако
          иногда этого не происходит. Без указания питания, АЦП всегда будет
          выдавать 0.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-4.png" />
          <p>Рисунок 30 Вид схемы.</p>
        </div>
        <p>
          Так как для выбранной модели микроконтроллера напряжение питания
          должно быть 3.3В, следует убедиться, что система Proteus назначила
          именно такое питание.
        </p>
        <p>Для этого в верхнем меню выбрать Design > Configure Power Rails.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-5.png" />
          <p>Рисунок 31 Настройка питания.</p>
        </div>
        <p>
          В поле Name выбрать VCC/VDD, при необходимости установить значение
          поля voltage = 3.3.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-6.png" />
          <p>Рисунок 32 Настройка питания.</p>
        </div>
        <p>
          Запустить проект. Если виртуальный терминал не появился, то вызвать
          его. Каждую секунду на виртуальный терминал будет выводиться текущее
          значение датчика.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-7.png" />
          <p>Рисунок 33 Результат.</p>
        </div>
        <p>
          В соответствии с вариантом сделать чтение АЦП на заданном канале, по
          нажатию кнопки.
        </p>
        <p>По завершению задания, выполнить тестирование.</p>
      </section>
      <section id="module3-3">
        <h3>Модуль 3.3. Таймер с прерыванием</h3>
        <h4>Задание</h4>
        <p>
          Рассмотреть пример работы таймера по прерыванию. Реализовать моргание
          светодиода по прерыванию на таймере и периодом в соответствии с
          вариантом.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Таймер: 2, период: 0.5 сек, порт светодиода: PA1</li>
          <li>Таймер: 3, период: 1.5 сек, порт светодиода: PB1</li>
          <li>Таймер: 4, период: 2 сек, порт светодиода: PC1</li>
          <li>Таймер: 5, период: 0.75 сек, порт светодиода: PD1</li>
          <li>Таймер: 2, период: 1.5 сек, порт светодиода: PE1</li>
          <li>Таймер: 3, период: 2.75 сек, порт светодиода: PA4</li>
          <li>Таймер: 4, период: 0.25 сек, порт светодиода: PC3</li>
          <li>Таймер: 5, период: 3 сек, порт светодиода: PD7</li>
          <li>Таймер: 2, период: 1.25 сек, порт светодиода: PB11</li>
          <li>Таймер: 3, период: 1.75 сек, порт светодиода: PE3</li>
          <li>Таймер: 4, период: 2.5 сек, порт светодиода: PC9</li>
          <li>Таймер: 5, период: 2.25 сек, порт светодиода: PA5</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект, включить тактирование, UART.</p>
        <p>
          Далее рассмотрен пример включения светодиода по прерыванию таймера 2 с
          периодом 1 сек.
        </p>
        <p>
          В разделе Timers выбрать таймер, в поле Clock Source указать Internal
          Source, это означает что будет выбран внутренний источник
          тактирования, для вариантов таймеров этого задания это будет шина
          APB2. По умолчанию частота этой шины 16МГц.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-1.png" />
          <p>Рисунок 34 Настройки таймера.</p>
        </div>
        <p>
          Принцип задания Prescaler и Counter Period точно такой же как в
          задании 3.1.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-9.png" />
          <p>Рисунок 35 Формула задания частоты таймера.</p>
        </div>
        <p>
          Однако стоит помнить, что светодиод также надо выключать, поэтому
          получается, что необходимо будет задать частоту в два раза больше.
          Поэтому значение Counter Period 4999, а не 9999.
        </p>
        <p>Как порт для светодиода был выбран PA1</p>
        <p>Сгенерировать код, включить генерацию hex-файла.</p>
        <p>
          Для включения таймера с прерыванием, необходимо перед циклом while
          написать следующий код.
        </p>
        <pre>
          HAL_TIM_Base_Start_IT(&htim2);
        </pre>
        <p>Обработка прерывания задаётся в файле stm32f4xx_it.c</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-2.png" />
          <p>Рисунок 36 файл для обработки прерывания.</p>
        </div>
        <p>
          В этом файле найти функцию обработки прерывания, так как для примера
          был выбран таймер 2, то название функции TIM2_IRQHandler
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-3.png" />
          <p>Рисунок 37 функция обработки прерывания.</p>
        </div>
        <p>
          Для переключения светодиода в теле функции было указано следующее:
        </p>
        <pre>
          HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1 );
        </pre>
        <p>Эта функция переключает значение порта на противоположное.</p>
        <p>Скомпилировать код, далее перейти к созданию проекта в Proteus.</p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Поместить микроконтроллер, для добавления светодиода ввести в
          поисковой строке "LED", далее выбрать светодиод любого цвета.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-4.png" />
          <p>Рисунок 38 добавление светодиода.</p>
        </div>
        <p>
          Так как симуляции может сильно нагружать рабочий компьютер, то скорее
          всего появится следующее предупреждение, о том, что анимация будет
          происходить с задержкой.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-5.png" />
          <p>Рисунок 39 Предупреждение.</p>
        </div>
        <p>
          В таком случае, визуально будет казаться, что светодиод моргает
          значительно реже, чем 1 раз в секунду, однако в том, что период 1
          секунда, можно убедиться подключив осциллограф.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-6.png" />
          <p>Рисунок 40 Результат.</p>
        </div>
        <p>По осциллографу видно, что светодиод включается каждую секунду.</p>
        <p>
          * Задание повышенной сложности: реализовать прерывания с несколькими
          таймерами с разным периодом.
        </p>
        <p>
          Для тестирования выводить Prescaler и Counter Period в следующем
          формате:
        </p>
        <pre>
          char buffer[100];
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer,
                  sprintf(buffer, "%d<>%dEND", htim2.Init.Prescaler, htim2.Init.Period), 100);</pre
        >
      </section>
      <section id="module3-4">
        <h3>Модуль 3.4. Управление углом сервомотора</h3>
        <h4>Задание</h4>
        <p>
          Доработать программу пример, задавать угол поворота сервомотора с
          помощью потенциометра. Сделать вывод угла поворота на виртуальный
          терминал по нажатию кнопки.
        </p>
        <p>
          * Задание повышенной сложности: сделать вывод значения угла поворота
          на ЖКИ.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Таймер: 1, канал таймера: 2, канал АЦП: 1</li>
          <li>Таймер: 2, канал таймера: 1, канал АЦП: 2</li>
          <li>Таймер: 3, канал таймера: 2, канал АЦП: 3</li>
          <li>Таймер: 4, канал таймера: 3, канал АЦП: 4</li>
          <li>Таймер: 5, канал таймера: 4, канал АЦП: 5</li>
          <li>Таймер: 1, канал таймера: 2, канал АЦП: 6</li>
          <li>Таймер: 2, канал таймера: 1, канал АЦП: 7</li>
          <li>Таймер: 3, канал таймера: 3, канал АЦП: 8</li>
          <li>Таймер: 4, канал таймера: 4, канал АЦП: 9</li>
          <li>Таймер: 5, канал таймера: 2, канал АЦП: 10</li>
          <li>Таймер: 1, канал таймера: 3, канал АЦП: 11</li>
          <li>Таймер: 2, канал таймера: 4, канал АЦП: 12</li>
        </ol>
        <p>
          Порт для кнопки подобрать самостоятельно. В случае конфликтов
          назначения портов, выбрать назначение конфликтного порта
          самостоятельно.
        </p>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект, включить тактирование, UART.</p>
        <p>
          Для примера будет рассмотрено использование 1-го канала таймера 1 и
          0-го канала АЦП.
        </p>
        <p>
          Указать канал АЦП, указать в заданном канале таймера значение PWM
          Generation CHX, где X - номер канала, остальные параметры таймера
          оставить по умолчанию.
        </p>
        <p>Сгенерировать код.</p>
        <p>Подключить библиотеку math</p>
        <pre>
          #include "math.h"
        </pre>
        <p>Перед циклом while добавить следующий код:</p>
        <pre>
          HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1); // запуск генератора ШИМ
          TIM1->CR1 &= 0xFFFE; // выключить выход таймера
          TIM1->PSC = 15; 
          TIM1->ARR = 19999;
          TIM1->CCR1 = 18500;
          TIM1->CR1 |= 0x1; // включить выход таймера
        </pre>
        <p>
          Для работы сервопривода требуется сигнал частотой 50Гц(20мс),
          длительностью сигнала задаётся угол поворота сервомотора, 1мс = -90(0)
          градусов, 1.5мс = 0 градусов, 2мс = 90(180) градусов. Длительность
          сигнала обязательно должна быть в пределах от 1 до 2 мс, если было
          другое, то сервомотор будет всегда оставаться в положении либо 0 либо
          180 градусов, в зависимости от длительности сигнала. По формуле
          известной из задания 3.1 задаются значения PSC и ARR. ARR выбрано
          19999, чтобы было удобнее задавать длительность сигнала. В регистр
          CCR1 записано значение 18500, что соответствет длительности сигнала
          1.5мс и углу 0 градусов.
        </p>
        <p>В цикле while добавить:</p>
        <pre>
          HAL_ADC_Start(&hadc1);
          HAL_ADC_PollForConversion(&hadc1, 100);
          ADC_val = HAL_ADC_GetValue(&hadc1);
          HAL_ADC_Stop(&hadc1);
          setServo(ADC_val);
        </pre>
        <p>Функция setServo:</p>
        <pre>
          uint32_t last;
          void setServo(uint16_t tmp) {
            double value = tmp;
            if (last != tmp) {
              last=tm
              TIM1->CR1 &= 0xFFFE;
             // TIM1->CCR1 = (int) value; 
              TIM1->CR1 |= 0x1;
            }
          }
        </pre>
        <p>
          Необходимо разобраться, какие преобразования нужно сделать, чтобы
          задавать угол поворота сервопривода с помощью потенциометра. Также
          преобразовать значение потенциометра в значения угла поворота(диапазон
          от 0 до 180, значение сервомотора 90 считать 0, 0 градусов считать 90,
          -90 считать 180 и так далее).
        </p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Для добавления сервомотора в поисковой строке ввести MOTOR-PWMSERVO.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-4.png" />
          <p>Рисунок 41 Добавление сервопривода.</p>
        </div>
        <p>Для добавления потенциометра в поисковой строке ввести POT-HG.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-5.png" />
          <p>Рисунок 42 Добавление потенциометра.</p>
        </div>
        <p>Пример подключения приведён ниже, в примерах работы программы.</p>
        <p>Примеры работы программы</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-1.png" />
          <p>Рисунок 43 Результат.</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-2.png" />
          <p>Рисунок 44 Результат.</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-3.png" />
          <p>Рисунок 45 Результат.</p>
        </div>
      </section>
    </div>
  </body>
</html>
