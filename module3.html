<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Методические указания.</title>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Модуль 3</h1>
        <h2>Содержание</h2>
        <nav>
          <ol>
            <li><a href="#introduction">Введение</a></li>
            <li>
              <a href="#module3-1">Генератор ШИМ</a>
            </li>
            <li>
              <a href="#module3-2">Работа с АЦП</a>
            </li>
            <li>
              <a href="#module3-3">Таймер с прерываниями</a>
            </li>
            <li>
              <a href="#module3-4">Управление углом сервомотора</a>
            </li>
          </ol>
        </nav>
      </header>
      <section id="introduction">
        <h2>Введение</h2>
        <section>
          <h3>Теоретическая часть</h3>
          <h4>Таймеры в STM32</h4>
          <p>
            В микроконтроллерах STM32 таймеры можно разделить на следующие
            группы:
          </p>
          <ul>
            <li>Расширенные (TIM1)</li>
            <li>Общего назначения (TIM2,TIM3,TIM4,TIM5)</li>
            <li>Базовые (все остальные таймеры)</li>
          </ul>
          <p>
            Стоить отметить, что у компании STM есть система именования
            таймеров, нумерация таймеров не последовательная, цифра означает
            принадлежность к типу. Таймеры с одинаковой цифрой в названии
            одинаковы на разных моделях микроконтроллеров.
          </p>
          <p>
            Самыми продвинутыми являются расширенные таймеры. Все остальные
            можно рассматривать как ограниченные версии расширенных. Обычно
            каждый микроконтроллер STM имеет хотя бы один расширенный таймер
            (TIM1).
          </p>
          <p>На рисунке ниже приведена структурная схема таймера 1.</p>
          <div class="imageBlock">
            <img src="./images/module_3/t-1.png" />
            <p>Рисунок 1 Структурная схема таймера</p>
          </div>
          <p>Эту же схему можно изобразить в упрощённом виде:</p>
          <div class="imageBlock">
            <img src="./images/module_3/t-2.png" />
            <p>Рисунок 2 упрощённая структурная схема таймера</p>
          </div>
          <p>Можно выделить следующие основные блоки:</p>
          <ul>
            <li>Времязадающий модуль (Time-base unit)</li>
            <li>Cхема управления (Controller)</li>
            <li>Набор каналов таймера (Channels)</li>
            <li>
              Схема останова (схема защитного отключения выходов каналов, Break)
            </li>
          </ul>
          <p>Связи между блоками указаны стрелками на схеме.</p>
          <p>
            Таймер имеет возможность взаимодействовать с внешним окружением, для
            этого имеются входы и выходы (входы/выходы каналов, вход ETR, вход
            BKIN). Некоторые таймеры микроконтроллера могут взаимодействовать
            между собой: для этого у них есть по одному внутреннему выходу
            триггерного сигнала (TRGO) и по 4 внутренних входа для триггерных
            сигналов ITR0, ITR1, ITR2, ITR3. Каждый триггерный вход данного
            таймера подключён к триггерному выходу другого определённого
            таймера. А триггерный выход может быть внутренне подключён к
            некоторому триггерному входу одного или нескольких других таймеров.
            Режим использования триггерных входов/выходов таймеров зависит от
            заданных настроек.
          </p>
          <p>
            Главным является времязадающий модуль, в нём главный элемент это
            счётчик. Счётчики универсальных таймеров в микроконтроллерах STM32
            являются 16-разрядными (однако иногда счётчики в TIM2, TIM5 могут
            быть 32-разрядными). Счётчик работает совместно с регистром
            автоперезагрузки, управляющим модулем пересчёта.Этот регистр
            определяет до(от) какого значения будет выполняться счёт, по
            достижению этого значения(либо нуля если счёт идёт "вниз"),
            происходит переполнение и сброс счётчика. Переполнение формирует
            специальный сигнал - событие обновления, по которому выполняется ряд
            важных действий, а также возможна генерация прерывания. Тактовый
            сигнал на счётчик поступает через предделитель с управляемым
            коэффициентом деления, который можно изменять в пределах от 1 до
            65536 (построен на базе 16-разрядного счётчика). На вход
            предделителя тактовый сигнал поступает со схемы управления.
          </p>
          <p>
            На схеме управления можно выбрать источник тактового сигнала
            (внутренний тактовый сигнал с шины; внешний триггерный сигнал ETR;
            внутренний триггерный сигнал; сигнал от энкодер-интерфейса). Схема
            управления определяет режим счёта (UP, DOWN, Center Aligned, но при
            условии что в таймере есть возможноость переключения режима).
            Направление счёта выбирается с помощью конфигурирующих битов, а в
            некоторых режимах зависит от состояния таймера и переключается
            автоматически(Center Aligned). При работе таймера в подчинённом
            режиме схема управления выбирает источник входного триггерного
            сигнала. Также схема управления генерирует выходной триггерный
            сигнал, который, в зависимости от настроек, может формироваться при
            переполнении счётчика таймера или в ответ на другие события.
          </p>
          <p>
            Схема управления и времязадающий модуль - это минимум того, что
            входит в состав любого таймера. Возможности таймера могут быть
            расширены за счёт наличия одного или нескольких каналов. Каналы
            предназначены для выполнения наиболее часто встречающихся на
            практике задач по генерации импульсных сигналов и для измерения
            параметров внешних импульсных сигналов и могут, соответственно,
            работать в режиме выхода или входа. Действия выполняемые каналами
            можно реализовать программно, однако аппаратное решение позволяет
            разгрузить процессор, тем самым увеличив быстродействие.
          </p>
          <p>
            В режиме входа канал выполняет сохранение текущего содержимого
            счётчика таймера в регистр канала по внешнему сигналу. Настройками
            можно задать источник сигнала и выбрать событие, по которому будет
            происходить фиксация (фронт или спад). По сохраненному в регистре
            канала значению, можно определить в какой момент времени произошло
            событие. Это можно выполнять программно, но в таком случае будет
            большая нагрузка на процессор.
          </p>
          <p>
            В режиме выхода канал используется для генерации сигналов. В регистр
            канала записывается определённое значение. Канал на каждом такте
            сравнивает текущее значение счётчика и значение в своём регистре и в
            зависимости от результата сравнения (и от настроек) изменяет
            состояние на своём выходе. Например, при равенстве значений может
            происходить формирование на выходе низкого или высокого уровня или
            переключение уровня на противоположный. Канал может иметь не один, а
            два комплементарных выхода, сигналы на которых изменяются в
            противофазе, с возможностью гибко задавать полярностью активных
            уровней этих сигналов и время задержки между сигналами при
            переключения. Точно также можно реализовать программно, но ценой
            большой нагрузки на процессор.
          </p>
          <h4>АЦП</h4>
          <p>АЦП в STM32 обладает следующими особенностями:</p>
          <ul>
            <li>Разрядность 12 бит</li>
            <li>Опорное напряжение от 2.4 до 3.6 Вольта</li>
            <li>Скорость оцифровки до 1MSPS</li>
            <li>
              18 каналов(16 внешних и 2 внутренних – опорное напряжение и
              температурный датчик)
            </li>
            <li>
              Прерывание по окончании регулярных и инжектированных
              преобразований
            </li>
            <li>Прерывание от оконного компаратора(Analog watchdog)</li>
            <li>Отправка данных по DMA для регулярных преобразований</li>
            <li>Одиночное и непрерывное преобразование</li>
            <li>Режим сканирования каналов по заданному списку</li>
            <li>Выравнивание результата по выбранному краю</li>
          </ul>
          <p>
            Измерение аналогового сигнала на входе происходит с определенной
            частотой (дискретно), чем выше частота измерения тем выше
            дискретизация измеряемого сигнала тем точнее произойдет
            преобразования аналогового сигнала в цифровой, который понятен
            микроконтроллеру.
          </p>
          <p>
            Режим регулярных преобразований. В этом режиме задаётся группа от 1
            до 16 каналов, обработка которых производится последовательно, а
            результат помещается в один 12-разрядный регистр, предполагается,
            что данные будут сохраняться с помощью DMA. Преобразования могут
            быть циклическими и периодическими, запускаться по таймеру или
            внешнему прерыванию.
          </p>
          <p>
            Режим инжектированных преобразований. В последовательность
            инжектированных преобразований может входить до 4 каналов, эти
            каналы имеют собственные регистры для сохранения результата. Запуск
            инжектированных преобразований останавливает регулярные(их работа
            возобновится по окончанию преобразований).
          </p>
          <p>
            Оконный компаратор. Его функция заключается в генерации прерывания
            при выходе результата преобразования за пределы заданных
            пользователем нижней и верхней границ (условия снижения и превышения
            напряжения, соответственно). Оконный компаратор может использоваться
            для мониторинга выбранного регулярного или инжектированного канала,
            или же всех регулярных или инжектированных каналов. Помимо
            мониторинга напряжения, функция оконного компаратора может
            использоваться в качестве детектора пересечения нуля.
          </p>
          <div class="imageBlock">
            <img src="./images/module_3/t-3.png" />
            <p>Рисунок 3 Схема АЦП</p>
          </div>
          <h4>LM35</h4>
          <p>
            В лабораторной работе для задания на работу с АЦП используется
            датчик температуры LM35.
          </p>
          <p>
            Серия LM35 это интегральные датчики температуры, у которых выходное
            напряжение пропорционально температуре по шкале Цельсия. Это одно из
            преимуществ над датчиками с выходным напряжением по шкале Кельвина.
            Не требуется вычитать высокостабильное напряжение из выходного
            напряжения для перевода в шкалу по Цельсию.
          </p>
          <p>
            LM35 обеспечивает измерение температуры с точностью ±0.25 °C в
            комнатных условиях и с точностью ±0.75 °C в полном диапазоне рабочих
            температур -55 … +150 °C, без внешней калибровки или подгонки
            выходного напряжения.
          </p>
          <p>У датчиков серии LM35 можно выделить следующие особенности:</p>
          <ul>
            <li>Значение температуры калибровано в шкале Цельсия.</li>
            <li>
              Линейное значение напряжения на выходе с коэффициентом 10 мВ/ °C.
            </li>
            <li>Гарантирована точность 0.5 °C (при 25 °C).</li>
            <li>
              Параметры нормированы для полного диапазона температур -55 … +150
              °C.
            </li>
            <li>
              Удобны для использования в устройствах с удаленным подключением
              датчиков.
            </li>
            <li>Низкая цена.</li>
            <li>Потребляемый ток менее 60 мкА.</li>
            <li>
              Низкое выходное сопротивление – 0.1 Ом, при токе нагрузки 1 мА.
            </li>
            <li>
              Низкий уровень собственного разогрева – 0.08 °C при неподвижном
              воздухе.
            </li>
          </ul>
          <div class="imageBlock">
            <img src="./images/module_3/t-4.png" />
            <p>Рисунок 4 структурная схема LM35</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_3/t-5.png" />
            <p>Рисунок 5 размеры LM35</p>
          </div>
          <h4>Сервомотор</h4>
          <p>
            Сервомоторы (от англ. Servo Motor) - следящие электродвигатели или
            серводвигателями, применяются в областях, где нужен точный контроль,
            например автоматизированное оборудование, роботизированные руки и
            т.п. Также используются и в других областях.
          </p>
          <p>
            Сервомоторы не могут вращаться на 360 градусов,поэтому не
            используются там, где требуется непрерывное вращение двигателя.
            Стандартный угол поворота 0-180 градусов или от -90 до +90 градусов.
          </p>
          <p>
            Сервопривод состоит из электродвигателя, постоянного тока, который
            приводит в действие редуктор, уменьшающий скорость вращения
            двигателя и, в то же время увеличивающий крутящий момент на валу.
            Для контроля положения выходного вала он соединен с датчиком
            положения (обычно это переменный резистор).Для того, чтобы управлять
            мощностью и направлением двигателя , схема управления использует
            входной сигнал от датчика положения в сочетании с сигналом
            управления, задающим требуемое положение.
          </p>
          <div class="imageBlock">
            <img src="./images/module_3/t-6.png" />
            <p>Рисунок 6 устройство сервопривода</p>
          </div>
          <p>
            Блок управления, получив через сигнал управления величину желаемого
            положения вала, вычитает из него величину действительного его
            положения и вырабатывает «сигнал ошибки», который может быть
            положительным или отрицательным. Этот «сигнал ошибки» подается на
            питание двигателя, заставляя его изменить положение вала в нужном
            направлении. Чем больше разница между желаемым и действительным
            положением выходного вала, тем быстрее двигатель будет
            поворачиваться к желаемой позиции. Чем ближе к нулю становится
            значение ошибки (рассогласования), тем меньше становится питание
            двигателя.
          </p>
          <p>
            Управляющий сигнал на серводвигатель - cигнал широтно-импульсной
            модуляции (ШИМ). Сигнал такого вида является стандартным для всех
            любительских сервомашинок.
          </p>
          <div class="imageBlock">
            <img src="./images/module_3/t-7.png" />
            <p>Рисунок 7 сигнал управления сервопривода</p>
          </div>
        </section>
      </section>
      <section id="module3-1">
        <h3>Модуль 3.1. Генератор ШИМ</h3>
        <h4>Задание</h4>
        <p>
          С помощью таймера 1 сгенерировать сигнал в соответсвии с вариантом
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Канал: 1, частота: 100Гц, скважность: 2</li>
          <li>Канал: 2, частота: 250Гц, скважность: 2</li>
          <li>Канал: 3, частота: 300Гц, скважность: 4</li>
          <li>Канал: 4, частота: 150Гц, скважность: 3</li>
          <li>Канал: 1, частота: 350Гц, скважность: 5</li>
          <li>Канал: 2, частота: 125Гц, скважность: 3</li>
          <li>Канал: 3, частота: 175Гц, скважность: 2</li>
          <li>Канал: 4, частота: 200Гц, скважность: 6</li>
          <li>Канал: 1, частота: 500Гц, скважность: 2</li>
          <li>Канал: 2, частота: 600Гц, скважность: 4</li>
          <li>Канал: 3, частота: 675Гц, скважность: 5</li>
          <li>Канал: 4, частота: 725Гц, скважность: 3</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>
          Создать проект, все действия по созданию проекта аналогичны предыдущим
          модулям, до этапа настроек.
        </p>
        <p>
          Включить тактирование. Далее перейти Timers > TIM1, в канале
          соответствующем варианту выбрать PWM Generation CHX, где X - номер
          канала по варианту.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-1.png" />
          <p>Рисунок 8 Настройка таймера</p>
        </div>
        <p>Далее перейти к разделу Parameter Setting > Counter Settings.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-3.png" />
          <p>Рисунок 9 Настройка таймера</p>
        </div>
        <p>Теперь необходимо разобраться о назначении каждого поля.</p>
        <p>
          Prescaler - предделитель системной частоты таймера. Предделитель это
          цифровой счётчик, который считает между тиками таймера. Если
          установить предделитель равным X, тогда между каждым тиком таймера,
          счётчик предделителя будет со скоростью системной частоты таймера
          отсчитывать от 0 до X и обнуляться. При каждом обнулении счётчика,
          таймер будет совершать очередной тик. Таким образом происходит деление
          частоты.
        </p>
        <p>
          Counter Mode - режим работы счётчика. Возможные варианты: UP, Down,
          Center Aligned Mode 1..3. UP - работа счетчика на прибавление, от 0 до
          X. Down - работа счетчика на вычитание, от X до 0. Center Aligned Mode
          - режим выравнивания по центру. В этом режиме счетчик считает от 0 до
          X, а затем считает в обратную сторону от X до 0.
        </p>
        <p>
          Для наглядности рассмотрен пример, когда значение переполнения
          счётчика задано 5.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-4.jpg" />
          <p>Рисунок 10 Выравнивание по краю</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-5.jpg" />
          <p>Рисунок 11 Выравнивание по центру</p>
        </div>
        <p>
          По рисунку видно, что длина и период импульса увеличиваются в 2 раза
          по сравнению с обычным режимом.
        </p>
        <p>
          Далее приведено объяснение различий между режимами 1, 2, 3. Разница в
          том, когда будет происходить прерывание, в случае если прерывание
          таймера было включено.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-6.jpg" />
          <p>Рисунок 12 Center Aligned mode 1</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-7.jpg" />
          <p>Рисунок 13 Center Aligned mode 2</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-8.jpg" />
          <p>Рисунок 14 Center Aligned mode 3</p>
        </div>
        <p>Counter Period — значение переполнения.</p>
        <p>
          Internal Clock Division - Делитель системной частоты таймера для
          формирования вспомогательного тактового сигнала, который используется
          в цифровых фильтрах, и для формирования времени запаздывания при
          работе в режиме PWM с комплементарными выходами (dead-time).
        </p>
        <p>
          Repetition Counter - количество переполнений для генерации прерывания.
          Если указать N, то прерывание будет вызываться на каждом N-ом
          переполнении.
        </p>
        <p>
          Auto-reload preload - необходимо для работы с дублирующими(буферным)
          регистрами таймера. Используется если в ходе работы изменяется
          значение переполнения.
        </p>
        <p>
          Теперь, после того, как стало понятно о назначении каждого поля, можно
          перейти к формуле: определяющей частоту генератора ШИМ.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-9.png" />
          <p>Рисунок 15 Формула для задания частоты</p>
        </div>
        <p>
          ARR - AutoReload Register, он же Counter Period. PSC - Prescaler.
          Clock - частота работы таймера. Почему к ARR и PSC прибавляется 1?
          Ответ: чтобы не было деления на 0.
        </p>
        <p>
          Из приведённой выше формулы, понятно, что задать частоту можно меняя
          значения clock, ARR, PSC. Чтобы не усложнять лабораторную работу
          настройкой частоты работы микроконтроллера, предполагается взять clock
          равным частоте работы микроконтроллера по умолчанию - 16МГц.
        </p>
        <p>
          Далее рассмотрен пример генератора ШИМ 1000Гц(1кГц) со скважностью 2
          на первом канале таймера 1.
        </p>
        <p>
          F = 1000, Для удобства задания скважности и выполнения расчётов
          (ARR+1) = 1000 => ARR = 999. Пусть PSC+1 = X. Необходимо выразить
          подставить известные числа в формулу и выразить X.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-10.png" />
          <p>Рисунок 16 Вывод значения PSC</p>
        </div>
        <p>
          Итого для создания генератора ШИМ 1000Гц(1кГц) со скважностью 2
          необходимо указать следующие параметры:
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-2.png" />
          <p>Рисунок 17 Настройки счётчика таймера</p>
        </div>
        <p>
          Далее подключить UART для тестирования, сгенерировать код, включить
          создание hex-файла.
        </p>
        <p>
          Порт на котором будет выходной сигнал будет подсвечен зелёным цветом,
          после выбора канала таймера. Для 1-го канала это PA8, для 2-го PA9,
          для 3-го PA10, для 4-го PA11.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-11.png" />
          <p>Рисунок 18 Выходной порт генератора ШИМ</p>
        </div>
        <p>Генератор ШИМ включается следующей командой:</p>
        <pre>HAL_TIM_PWM_Start(&htimX, TIM_CHANNEL_Y);</pre>
        <p>
          &htimX - это указатель на таймер, X - номер таймера. TIM_CHANNEL_Y -
          указатель номера канала таймера, Y - номер канала. Так как по
          настройкам было задано создание на первом канале первого таймера, то
          код будет выглядеть следующим образом.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-12.png" />
          <p>Рисунок 19 Код генератора ШИМ</p>
        </div>
        <p>
          Скважность задаётся записью числа в регистр CCRX, где X номер канала.
          Значение в этом регистре определяет скважность сигнала. Это число
          до(либо после, это зависит от настроек счетчика) значения которого
          будет генерироваться сигнал. Так в данном примере счётчик считает от 0
          до 1000 (стоит помнить о прибавляемой 1 к заданному пределу счетчика),
          то для задания скважности 2 было установлено значение 500.
        </p>
        <p>
          Сгенерировать код, далее перейти к созданию проекта в среде Proteus.
        </p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          В среде Proteus поместить микроконтроллер, добавить
          осциллограф(OSCILLOSCOPE) и счётчик(COUNTER TIMER).Для этого выбрать
          соответствующий пункт в левом боковом меню.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-13.png" />
          <p>Рисунок 20 Подключение осциллографа и счётчика.</p>
        </div>
        <p>
          Осциллограф и счтчик подключить к порту-выходу генератора ШИМ, для
          этого примера это PA8.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-14.png" />
          <p>Рисунок 21 Подключение осциллографа и счётчика.</p>
        </div>
        <p>
          Счётчик понадобится для определения частоты, для этого необходимо
          поменять настройка. Правой кнопкой мыши кликнуть по счётчику, выбрать
          Edit Properties. Выполнить настройку в соответсвии с рисунком.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-15.png" />
          <p>Рисунок 22 Настройка счётчика.</p>
        </div>
        <p>
          Далее запустить проект, если окно с значениями осциллографа не
          появилось, вызвать его через меню.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-16.png" />
          <p>Рисунок 23 Вызов окна осциллографа.</p>
        </div>
        <p>Ожидается получение следующих результатов:</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-17.png" />
          <p>Рисунок 24 Результаты.</p>
        </div>
        <p>
          Как видно был получен сигнал со скважностью 2 и периодом 1мс, что
          соответствует частоте 1000Гц(1кГц). Значение на счётчике 1001(обычно в
          пределах 999-1001),считать это погрешностью среды Proteus, по
          осциллографу чётко видно период 1мс.
        </p>
        <p>
          Для демонстрации, далее скважность была изменена на 4. Для этого в
          коде были сделаны следующие изменения: в переменную PWM было записано
          значение 750, следовательно длительность импульса будет 250(1000-750)
          отсчётов счётчика.
        </p>
        <pre>int pwm = 750;</pre>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-18.png" />
          <p>Рисунок 25 Результат со скважностью 4.</p>
        </div>
        <p>Видно, что сигнал изменился, и скважность стала 4.</p>
        <p>
          Реализовать генератор ШИМ в соответствии с заданием варианта, для
          тестирования, на виртуальный порт отправлять данные в следующем
          формате:
        </p>
        <pre>
          char buffer[100];
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer,
                  sprintf(buffer, "%d<>%d<>%dEND", pwm, htim1.Init.Prescaler, htim1.Init.Period), 100);</pre
        >
        <p>
          * Задание повышенной сложности, реализовать генератор ШИМ с переменной
          скважностью. Пример результата приведён ниже
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-19.png" />
          <p>Рисунок 26 Результат c переменной скважностью.</p>
        </div>
      </section>
      <section id="module3-2">
        <h3>Модуль 3.2. Работа с АЦП</h3>
        <h4>Задание</h4>
        <p>
          Рассмотреть пример использования АЦП. На основе примера реализовать
          программу считывающую значение температуры с датчика LM35 по нажатию
          кнопки, на заданном канале АЦП.
        </p>
        <p>
          * Задание повышенной сложности: сделать вывод значений температуры на
          ЖКИ.
        </p>
        <p>
          ** Задание повышенной сложности: сделать вывод отрицательной
          температуры.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Канал АЦП: 1, порт для кнопки: PB1</li>
          <li>Канал АЦП: 2, порт для кнопки: PD0</li>
          <li>Канал АЦП: 3, порт для кнопки: PE3</li>
          <li>Канал АЦП: 4, порт для кнопки: PC6</li>
          <li>Канал АЦП: 5, порт для кнопки: PС4</li>
          <li>Канал АЦП: 6, порт для кнопки: PE10</li>
          <li>Канал АЦП: 7, порт для кнопки: PA1</li>
          <li>Канал АЦП: 8, порт для кнопки: PD2</li>
          <li>Канал АЦП: 9, порт для кнопки: PA2</li>
          <li>Канал АЦП: 10, порт для кнопки: PB9</li>
          <li>Канал АЦП: 11, порт для кнопки: PC6</li>
          <li>Канал АЦП: 12, порт для кнопки: PA11</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект. Включить тактирование, подключить UART.</p>
        <p>
          Для включения АЦП, необходимо в меню ANALOG указать рабочий канал для
          АЦП. Остальные настройки оставить как есть.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-1.png" />
          <p>Рисунок 27 Включение АЦП.</p>
        </div>
        <p>
          После выбора канала, входной порт для АЦП будет подсвечен зелёным.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-2.png" />
          <p>Рисунок 28 входной порт АЦП.</p>
        </div>
        <p>Далее сгенерировать код. Включить создание hex-файла.</p>
        <p>
          Ниже приведён фрагмент кода для считывания значения датчика с АЦП.
        </p>
        <pre>
          HAL_ADC_Start(&hadc1); // запуск АЦП, как параметр передан указатель на АЦП.
          HAL_ADC_PollForConversion(&hadc1, 100); // Ожидание, пока АЦП преобразует значение, как параметры указатель на АЦП и время преобразования
          ADC_val = HAL_ADC_GetValue(&hadc1); // получение значения АЦП
          HAL_ADC_Stop(&hadc1); // остановка АЦП
          printTemp(ADC_val); // функция для обработки значения АЦП
          HAL_Delay(1000); // задержка 1 секунда
        </pre>
        <p>Функция преобразования значения АЦП:</p>
        <pre>
          void printTemp(uint16_t tmp) {
            uint32_t numVar = (tmp * 8.0586);
            char buffer[100];
            HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%.3d\n\r", numVar/100), 100);
          }
        </pre>
        <p>
          Почему входное значение функции умножается на 8.0586? Ответ: АЦП имеет
          разрядность 12 бит, 2^12 = 4096. 1 шаг АЦП будет (Vmax - Vmin)/(Число
          шагов - 1). Для выбранного микроконтроллера Vmax = 3.3В, Vmin = 0.
          Получается (3.3-0)/4095 = 8.0586. По информации из Datasheet LM35, 1
          градус = 10мВ, поэтому полученное значение необходимо разделить на
          100. Дробная часть в этом примере не обрабатывается.
        </p>
        <p>Скомпилировать код, перейти к созданию проекта в Proteus.</p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Поместить микроконтроллер. Для добавления датчика LM35, вызвать меню
          добавления элементов, в поисковой строке ввести "LM35".
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-3.png" />
          <p>Рисунок 29 Добавление датчика температуры.</p>
        </div>
        <p>
          Поместить все элементы на рабочем полем. Далее важным шагом для
          корректной работы АЦП является подключение питания к микроконтроллеру.
          Обычно система Proteus самостоятельно подключает питание, однако
          иногда этого не происходит. Без указания питания, АЦП всегда будет
          выдавать 0.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-4.png" />
          <p>Рисунок 30 Вид схемы.</p>
        </div>
        <p>
          Так как для выбранной модели микроконтроллера напряжение питания
          должно быть 3.3В, следует убедиться, что система Proteus назначила
          именно такое питание.
        </p>
        <p>Для этого в верхнем меню выбрать Design > Configure Power Rails.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-5.png" />
          <p>Рисунок 31 Настройка питания.</p>
        </div>
        <p>
          В поле Name выбрать VCC/VDD, при необходимости установить значение
          поля voltage = 3.3.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-6.png" />
          <p>Рисунок 32 Настройка питания.</p>
        </div>
        <p>
          Запустить проект. Если виртуальный терминал не появился, то вызвать
          его. Каждую секунду на виртуальный терминал будет выводиться текущее
          значение датчика.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-2-7.png" />
          <p>Рисунок 33 Результат.</p>
        </div>
        <p>
          В соответствии с вариантом сделать чтение АЦП на заданном канале, по
          нажатию кнопки.
        </p>
        <p>По завершению задания, выполнить тестирование.</p>
      </section>
      <section id="module3-3">
        <h3>Модуль 3.3. Таймер с прерыванием</h3>
        <h4>Задание</h4>
        <p>
          Рассмотреть пример работы таймера по прерыванию. Реализовать моргание
          светодиода по прерыванию на таймере и периодом в соответствии с
          вариантом.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Таймер: 2, период: 0.5 сек, порт светодиода: PA1</li>
          <li>Таймер: 3, период: 1.5 сек, порт светодиода: PB1</li>
          <li>Таймер: 4, период: 2 сек, порт светодиода: PC1</li>
          <li>Таймер: 5, период: 0.75 сек, порт светодиода: PD1</li>
          <li>Таймер: 2, период: 1.5 сек, порт светодиода: PE1</li>
          <li>Таймер: 3, период: 2.75 сек, порт светодиода: PA4</li>
          <li>Таймер: 4, период: 0.25 сек, порт светодиода: PC3</li>
          <li>Таймер: 5, период: 3 сек, порт светодиода: PD7</li>
          <li>Таймер: 2, период: 1.25 сек, порт светодиода: PB11</li>
          <li>Таймер: 3, период: 1.75 сек, порт светодиода: PE3</li>
          <li>Таймер: 4, период: 2.5 сек, порт светодиода: PC9</li>
          <li>Таймер: 5, период: 2.25 сек, порт светодиода: PA5</li>
        </ol>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект, включить тактирование, UART.</p>
        <p>
          Далее рассмотрен пример включения светодиода по прерыванию таймера 2 с
          периодом 1 сек.
        </p>
        <p>
          В разделе Timers выбрать таймер, в поле Clock Source указать Internal
          Source, это означает что будет выбран внутренний источник
          тактирования, для вариантов таймеров этого задания это будет шина
          APB2. По умолчанию частота этой шины 16МГц.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-1.png" />
          <p>Рисунок 34 Настройки таймера.</p>
        </div>
        <p>
          Принцип задания Prescaler и Counter Period точно такой же как в
          задании 3.1.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-1-9.png" />
          <p>Рисунок 35 Формула задания частоты таймера.</p>
        </div>
        <p>
          Однако стоит помнить, что светодиод также надо выключать, поэтому
          получается, что необходимо будет задать частоту в два раза больше.
          Поэтому значение Counter Period 4999, а не 9999.
        </p>
        <p>Как порт для светодиода был выбран PA1</p>
        <p>Сгенерировать код, включить генерацию hex-файла.</p>
        <p>
          Для включения таймера с прерыванием, необходимо перед циклом while
          написать следующий код.
        </p>
        <pre>
          HAL_TIM_Base_Start_IT(&htim2);
        </pre>
        <p>Обработка прерывания задаётся в файле stm32f4xx_it.c</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-2.png" />
          <p>Рисунок 36 файл для обработки прерывания.</p>
        </div>
        <p>
          В этом файле найти функцию обработки прерывания, так как для примера
          был выбран таймер 2, то название функции TIM2_IRQHandler
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-3.png" />
          <p>Рисунок 37 функция обработки прерывания.</p>
        </div>
        <p>
          Для переключения светодиода в теле функции было указано следующее:
        </p>
        <pre>
          HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1 );
        </pre>
        <p>Эта функция переключает значение порта на противоположное.</p>
        <p>Скомпилировать код, далее перейти к созданию проекта в Proteus.</p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Поместить микроконтроллер, для добавления светодиода ввести в
          поисковой строке "LED", далее выбрать светодиод любого цвета.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-4.png" />
          <p>Рисунок 38 добавление светодиода.</p>
        </div>
        <p>
          Так как симуляции может сильно нагружать рабочий компьютер, то скорее
          всего появится следующее предупреждение, о том, что анимация будет
          происходить с задержкой.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-5.png" />
          <p>Рисунок 39 Предупреждение.</p>
        </div>
        <p>
          В таком случае, визуально будет казаться, что светодиод моргает
          значительно реже, чем 1 раз в секунду, однако в том, что период 1
          секунда, можно убедиться подключив осциллограф.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-3-6.png" />
          <p>Рисунок 40 Результат.</p>
        </div>
        <p>По осциллографу видно, что светодиод включается каждую секунду.</p>
        <p>
          * Задание повышенной сложности: реализовать прерывания с несколькими
          таймерами с разным периодом.
        </p>
        <p>
          Для тестирования выводить Prescaler и Counter Period в следующем
          формате:
        </p>
        <pre>
          char buffer[100];
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer,
                  sprintf(buffer, "%d<>%dEND", htim2.Init.Prescaler, htim2.Init.Period), 100);</pre
        >
      </section>
      <section id="module3-4">
        <h3>Модуль 3.4. Управление углом сервомотора</h3>
        <h4>Задание</h4>
        <p>
          Доработать программу пример, задавать угол поворота сервомотора с
          помощью потенциометра. Сделать вывод угла поворота на виртуальный
          терминал по нажатию кнопки.
        </p>
        <p>
          * Задание повышенной сложности: сделать вывод значения угла поворота
          на ЖКИ.
        </p>
        <p>Варианты:</p>
        <ol class="math">
          <li>Таймер: 1, канал таймера: 2, канал АЦП: 1</li>
          <li>Таймер: 2, канал таймера: 1, канал АЦП: 2</li>
          <li>Таймер: 3, канал таймера: 2, канал АЦП: 3</li>
          <li>Таймер: 4, канал таймера: 3, канал АЦП: 4</li>
          <li>Таймер: 5, канал таймера: 4, канал АЦП: 5</li>
          <li>Таймер: 1, канал таймера: 2, канал АЦП: 6</li>
          <li>Таймер: 2, канал таймера: 1, канал АЦП: 7</li>
          <li>Таймер: 3, канал таймера: 3, канал АЦП: 8</li>
          <li>Таймер: 4, канал таймера: 4, канал АЦП: 9</li>
          <li>Таймер: 5, канал таймера: 2, канал АЦП: 10</li>
          <li>Таймер: 1, канал таймера: 3, канал АЦП: 11</li>
          <li>Таймер: 2, канал таймера: 4, канал АЦП: 12</li>
        </ol>
        <p>
          Порт для кнопки подобрать самостоятельно. В случае конфликтов
          назначения портов, выбрать назначение конфликтного порта
          самостоятельно.
        </p>
        <h4>Настройка проекта в STM32CubeIDE</h4>
        <p>Создать проект, включить тактирование, UART.</p>
        <p>
          Для примера будет рассмотрено использование 1-го канала таймера 1 и
          0-го канала АЦП.
        </p>
        <p>
          Указать канал АЦП, указать в заданном канале таймера значение PWM
          Generation CHX, где X - номер канала, остальные параметры таймера
          оставить по умолчанию.
        </p>
        <p>Сгенерировать код.</p>
        <p>Подключить библиотеку math</p>
        <pre>
          #include "math.h"
        </pre>
        <p>Перед циклом while добавить следующий код:</p>
        <pre>
          HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1); // запуск генератора ШИМ
          TIM1->CR1 &= 0xFFFE; // выключить выход таймера
          TIM1->PSC = 15; 
          TIM1->ARR = 19999;
          TIM1->CCR1 = 18500;
          TIM1->CR1 |= 0x1; // включить выход таймера
        </pre>
        <p>
          Для работы сервопривода требуется сигнал частотой 50Гц(20мс),
          длительностью сигнала задаётся угол поворота сервомотора, 1мс = -90(0)
          градусов, 1.5мс = 0 градусов, 2мс = 90(180) градусов. Длительность
          сигнала обязательно должна быть в пределах от 1 до 2 мс. По формуле
          известной из задания 3.1 задаются значения PSC и ARR. ARR выбрано
          19999, чтобы было удобнее задавать длительность сигнала. В регистр
          CCR1 записано значение 18500, что соответствет длительности сигнала
          1.5мс и углу 0 градусов.
        </p>
        <p>В цикле while добавить:</p>
        <pre>
          HAL_ADC_Start(&hadc1);
          HAL_ADC_PollForConversion(&hadc1, 100);
          ADC_val = HAL_ADC_GetValue(&hadc1);
          HAL_ADC_Stop(&hadc1);
          setServo(ADC_val);
        </pre>
        <p>Функция setServo:</p>
        <pre>
          uint32_t last;
          void setServo(uint16_t tmp) {
            double value = tmp;
            if (last != tmp) {
              last=tm
              TIM1->CR1 &= 0xFFFE;
             // TIM1->CCR1 = (int) value; 
              TIM1->CR1 |= 0x1;
            }
          }
        </pre>
        <p>
          Необходимо разобраться, какие преобразования нужно сделать, чтобы
          задавать угол поворота сервопривода с помощью потенциометра. Также
          преобразовать значение потенциометра в значения угла поворота(диапазон
          от 0 до 180, значение сервомотора 90 считать 0, 0 градусов считать 90,
          -90 считать 180 и так далее).
        </p>
        <h4>Настройка проекта в Proteus</h4>
        <p>
          Для добавления сервомотора в поисковой строке ввести MOTOR-PWMSERVO.
        </p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-4.png" />
          <p>Рисунок 41 Добавление сервопривода.</p>
        </div>
        <p>Для добавления потенциометра в поисковой строке ввести POT-HG.</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-5.png" />
          <p>Рисунок 42 Добавление потенциометра.</p>
        </div>
        <p>Пример подключения приведён ниже, в примерах работы программы.</p>
        <p>Примеры работы программы</p>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-1.png" />
          <p>Рисунок 43 Результат.</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-2.png" />
          <p>Рисунок 44 Результат.</p>
        </div>
        <div class="imageBlock">
          <img src="./images/module_3/3-4-3.png" />
          <p>Рисунок 45 Результат.</p>
        </div>
      </section>
    </div>
  </body>
</html>
