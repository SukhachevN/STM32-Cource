<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <!-- <script
      type="text/javascript"
      async
      src="/MathJax/MathJax.js?config=TeX-MML-AM_CHTML"
    ></script> -->
    <title>Методические указания.</title>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Модуль 1</h1>
        <h2>Содержание</h2>
        <nav>
          <ol>
            <li><a href="#introduction">Введение</a></li>
            <li><a href="#testing">Тестирование</a></li>
            <li>
              <a href="#module1-1"
                >Арифметические операции с целыми беззнаковыми десятичными
                числами</a
              >
            </li>
            <li>
              <a href="#module1-2"
                >Арифметические операции с рациональными десятичными числами</a
              >
            </li>
            <li><a href="#module1-3">Логические операции</a></li>
            <li><a href="#module1-4">Заполнение памяти</a></li>
          </ol>
        </nav>
      </header>
      <section id="introduction">
        <h2>Введение</h2>
        <section>
          <h3>Теоретическая часть</h3>
          <h4>Краткая информация о STM32</h4>
          <p>
            STM32 — семейство 32-битных микроконтроллеров производства
            STMicroelectronics. Чипы STM32 группируются в серии, в рамках каждой
            из которых используется одно и то же 32-битное ядро ARM
          </p>
          <p>
            Каждый микроконтроллер состоит из ядра процессора, статической
            RAM-памяти, флеш-памяти, отладочного и различных периферийных
            интерфейсов.
          </p>
          <p>
            Семейство микроконтроллеров STM32 состоит из 16 серий: F0, F1, F2,
            F3, F4, F7, L0, L1, L4, L4+, L5, G0, G4, H7, WB, WL
          </p>
          <p>Сама компания STM делит все серии на 4 группы:</p>
          <ul>
            <li>Высокопроизводительные - F2, F4, F7, H7</li>
            <li>Широкого применения - F0, G0, F1, F3, G4</li>
            <li>Сверхнизкого потребления - L0, L1, L4, L4+, L5</li>
            <li>Беспроводные - WB, WL</li>
          </ul>
          <h4>STM32F401VE</h4>
          <p>
            Выполнение лабораторных работ будет происходить на микроконтроллере
            модели STM32F401VE с ядром CORTEX-M4
          </p>
          <p>
            Этот микроконтроллер изначально доступен в среде Proteus 8.9, и не
            требует дополнительной установки каких либо пакетов
          </p>
          <p>Технические характеристики STM32F401VE:</p>
          <p>Ядро:</p>
          <ul>
            <li>ARM®32-bit Cortex®-M4 CPU with FPU</li>
            <li>
              ART Accelerator ™, позволяющий выполнять операции с нулевым
              ожиданием из флэш-памяти
            </li>
            <li>Частота работы до 84 МГц</li>
            <li>Блок защиты памяти</li>
            <li>Инструкции DSP (digital signal processor)</li>
          </ul>
          <p>Память:</p>
          <ul>
            <li>512 КБайт FLASH памяти</li>
            <li>96 Кбайт SRAM памяти</li>
          </ul>
          <p>Тактирование и питание:</p>
          <ul>
            <li>Напряжение портов ввода/вывода от 1.7 V до 3.6 V</li>
            <li>
              <p>POR, PDR, PVD и BOR</p>
              <p>
                BOR (Brownout Reset) это блок, который сохраняет состояние
                сброса микроконтроллера для тех пор, пока напряжение питания не
                достигнет заданного порогового значения VBOR. VBOR настраивается
                через Option bytes микроконтроллера. По умолчанию BOR выключен.
                Пользователь может выбрать от трех до пяти программируемых
                пороговых значений VBOR.
              </p>
              <p>
                POR (Power On Reset)/PDR (Power Down Reset), выполняет ту же
                операцию, что и BOR, но с фиксированным и, настроенным на
                заводе, пороговым значением напряжения.
              </p>
              <p>
                Прошивка устройства может активно контролировать электропитание
                с помощью программируемого детектора напряжения PVD
                (Programmable Voltage Detector). PVD позволяет настроить
                напряжение для мониторинга, и если это напряжение VDD выше или
                ниже заданного уровня, то устанавливается соответствующий бит в
                регистре управления питанием
              </p>
            </li>
            <li>Кварцевый генератор от 4 до 26 МГц</li>
            <li>Генератор 2 кГц для RTC(real time clock) с калибровкой.</li>
          </ul>
          <p>Потребляемая мощность:</p>
          <ul>
            <li>
              В режиме работе: 146 мкА / МГц , при условии, что перефирийные
              устройства отключены
            </li>
            <li>
              В режиме остановки (Flash в режиме остановки, быстрое
              пробуждение): от 42 до 62 мкА
            </li>
            <li>
              В режиме остановки (Flash в режиме глубокого сна, быстрое
              пробуждение): : от 10 до 30 мкА
            </li>
            <li>В режиме ожидания: 2,4 мкА (без RTC)</li>
            <li>Питание VBAT для RTC: 1 мкА</li>
          </ul>
          <p>
            1 × 12-битный аналого-цифровой преобразователь 2,4 MSPS: до 16
            каналов
          </p>
          <p>
            Универсальный DMA: 16-потоковый DMA с FIFO и пакетной поддержкой.
            DMA - direct memory access
          </p>
          <p>
            До 11 таймеров: 6 × 16-битных, 2 × 32-битных таймера до 84 МГц, в
            каждом до четырех IC(Input Capture) / OC(Output Compare) / PWM или
            счетчик импульсов и квадратурный (инкрементальный) вход энкодера,
            два watchdog (сторожевых таймера) таймера и таймер SysTick.
            <br />
            Квадратурный энкодер - устройство, позволяющее преобразовывать
            движение в импульсы.
          </p>
          <p>Режим отладки</p>
          <ul>
            <li>Serial wire debug (SWD) & JTAG interfaces</li>
            <li>Cortex®-M4 Embedded Trace Macrocell™</li>
          </ul>
          <p>81 порт ввода/вывода</p>
          <p>12 интерфейсов связи</p>
          <ul>
            <li>3 × I<sup>2</sup>C</li>
            <li>3 × USART ( 2 × 10.5 Мбит/с, 1 × 5.25 Мбит/c</li>
            <li>4 × SPI (42 Мбит/с fCPU = 84 МГц)</li>
            <li>1 × SDIO</li>
            <li>1 × USB 2.0</li>
          </ul>
          <p>Устройство расчёта циклического избыточного кода (CRC unit)</p>
          <p>
            96 бит уникального ID. Каждый микроконтроллер STM32 снабжён
            уникальным серийным номером, который зашивается на заводе в область
            памяти доступную только для чтения. Данный уникальный серийный номер
            может быть использован для:
          </p>
          <ul>
            <li>Адресации в сети</li>
            <li>Как криптоключ</li>
            <li>Реализации генератора случайных чисел</li>
          </ul>

          <p>RTC: субсекундная точность, аппаратный календарь</p>
          <p>Работа при температуре от –40 to +105 °C</p>
          <p>
            Всё выше перечисленное позволяет применять микроконтроллер
            STM32F401VE во многих областях:
          </p>
          <ul>
            <li>Управление моторным приводом</li>
            <li>Медицинское оборудование</li>
            <li>
              Промышленное применение: программируемые логические контроллеры,
              инверторы , автоматические выключатели
            </li>
            <li>Принтеры, сканеры</li>
            <li>
              Системы сигнализации, видеодомофоны, HVAC (Heating, Ventilation, &
              Air Conditioning - отопление, вентиляция, кондиционирование)
            </li>
            <li>Бытовая аудиотехника</li>
            <li>Сенсорный концентратор мобильного телефона</li>
          </ul>
          <div class="imageBlock">
            <img src="./images/module_1/structure-scheme.png" />
            <p>Рисунок 1 структурная схема STM32F401VE</p>
          </div>
          <p>
            Для STM32F401VE существует два варианта корпуса это LQFP100 и
            UFBGA100. Выводы для каждого из корпусов представлены на рисунках
            ниже
          </p>
          <div class="imageBlock">
            <img src="./images/module_1/IO-scheme.png" />
            <p>Рисунок 2 выводы STM32F401VE, корпус LQFP100</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_1/IO-scheme.png" />
            <p>Рисунок 3 выводы STM32F401VE, корпус UFBGA100</p>
          </div>
          <p>
            UFBGA100 имеет несколько больше возможностей в виде наличия
            дополнительных портов по сравнению с LQFP100, поэтому выполнение
            лабораторных работ будет проходить на микроконтроллере с этим типом
            корпуса
          </p>
          <p>Обозначения портов представлены в таблице ниже</p>
          <p>Расшифровка обозначений в таблице:</p>
          <ul>
            Значения Pin type - тип порта
            <li>S - питание</li>
            <li>I - только входные данные</li>
            <li>I/O - вход/выход</li>
            I/O structure - структура порта ввода/вывода
            <li>FT - устойчив к напряжению 5 В</li>
          </ul>
          <div class="imageBlock">
            <img src="./images/module_1/IO-table-1.png" />
            <p>Рисунок 4 обозначения портов</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_1/IO-table-2.png" />
            <p>Рисунок 5 обозначения портов (продолжение)</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_1/IO-table-3.png" />
            <p>Рисунок 6 обозначения портов (продолжение)</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_1/IO-table-4.png" />
            <p>Рисунок 7 обозначения портов (продолжение)</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_1/IO-table-5.png" />
            <p>Рисунок 8 обозначения портов (продолжение)</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_1/IO-table-6.png" />
            <p>Рисунок 9 обозначения портов (продолжение)</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_1/IO-table-7.png" />
            <p>Рисунок 10 обозначения портов (продолжение)</p>
          </div>
          <p>
            Почему на 32х разрядном микроконтроллере каждый порт имеет всего по
            16 входов/выходов, а не по 32?
          </p>
          <p>
            Самое простое объяснение это цена. Большая размерность порта
            является причиной более высокой цены. Количество приложений, которые
            используют 32-х разрядные порты слишком мало, по сравнению с
            приложениями, использующими 2 16-ти разрядных или 4 8-ми разрядных
            портов. Использование 32-х разрядного порта можно разделить на
            использование портов меньшей разрядности. Кроме того микроконтроллер
            с портами настроенными как 32 разряда будет менее полезен для
            большинства пользователей, чем микроконтроллер с большим количеством
            портов меньшей разрядности.
          </p>
        </section>
        <section>
          <h3>Практическая часть</h3>
          <p>
            В этом разделе происходит ознакомление с созданием и настройкой
            первого проекта на основе ARM микроконтроллера семейства Cortex-M4
          </p>
          <p>
            Написание программы "Hello World!". Чтобы сделать это необходимо
            создать 2 части : программную - написать код в STM32CubeIDE, и
            аппаратную, создать схему в Proteus
          </p>
          <section>
            <h3>Создание и настройка проекта в STM32CubeIDE</h3>
            <p>Открыть STM32CubeIDE. Выбрать File > New > STM32 Project</p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-1.png" />
              <p>Рисунок 11 Создание проекта в STM32CubeIDE</p>
            </div>
            <p>
              Далее в поле "Part number" ввести <b>STM32F401VE</b>. Кликнуть на
              название в списке и нажать "Next"
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-2.png" />
              <p>Рисунок 12 Выбор модели микроконтроллера в STM32CubeIDE</p>
            </div>
            <p>Ввести имя для проекта и нажать "Finish".</p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-3.png" />
              <p>Рисунок 13 Название проекта</p>
            </div>
            <p>
              Включение тактирования. Для этого в правом боковом меню выбрать
              "RCC". В поле "High Speed Clock" выбрать "Crystal/Ceramic
              Resonator"
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-4.png" />
              <p>Рисунок 14 настройка тактирования</p>
            </div>
            <p>
              Сам по себе микроконтроллер не может визуально отображать данные.
              Чтобы решить эту проблему, необходимо реализовать передачу данных
              по UART на устройство, способное отображать информацию. Однако по
              умолчанию порт для UART выключен в микроконтроллере, поэтому
              необходимо включить его.
            </p>
            <p>
              В правом левом меню перейти в раздел "Connectivity". Здесь можно
              увидеть список всего того, что можно подключить к
              микроконтроллеру. Выбрать "USART1". В поле Mode выбрать
              "Asynchronous". Также стоит обратить внимание на настройки UART,
              Видно, что по умолчанию Baud Rate установлен 115200. Это
              количество бит передаваемых микроконтроллером по UART за 1 секунду
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-5.png" />
              <p>Рисунок 15 настройка UART</p>
            </div>
            <p>
              После того как был включен UART, на pinout можно увидеть на какие
              порты он был назначен. Это порты PB6(TX) и PB7(RX). TX - для
              передачи, RX - для приёма.
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-6.png" />
              <p>Рисунок 16 Pinout</p>
            </div>
            <p>
              Теперь проект настроен. Можно переходить к генерации кода. В
              STM32CubeIDE есть возможность сгенерировать базовый код в
              соответствии с настройками, указанными при создании проекта Для
              генерации кода нажать кнопку "Build" с изображением молотка 🔨.
              Далее нажимать "yes" во всех появляющихся окнах.
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-7.png" />
              <p>Рисунок 17 Генерация кода</p>
            </div>
            <p>
              Перед тем как начать писать код, необходимо настроить компиляцию.
              А именно добавить генерацию .hex файла, это будет необходимо для
              реализации симуляции в системе Proteus. Для этого надо перейти
              Project > Properties
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-8-2.png" />
              <p>Рисунок 17 Настройка проекта</p>
            </div>
            <p>
              В появившемся окне выбрать C/C++ Build > Setting . Далее кликнуть
              на "MCU Post build outputs". Поставить галочку в поле "Convert to
              Intel Hex file (-O ihex)".
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-8.png" />
              <p>Рисунок 18 Настройка проекта</p>
            </div>
            <p>
              Написание кода. Чтобы вывести какие-либо данные, необходимо
              создать переменную для этих данных. Для хранения строки "Hello
              World!" была объявлена переменная с именем var с типом массив.
              Чтобы передать данную строку по UART необходимо использовать
              библиотечную функцию HAL_UART_Transmit. Данная функция принимает
              как параметры: модуль uart, по которому будет осуществляться
              передача данных (при настройке был выбран uart1), указатель на
              буфер данных, размер данных ( В примере передано число 12, так как
              12 это длина строки "Hello World!"), и длительность timeout.
            </p>
            <p>Итого необходимо добавить 2 строки в сгенерированный код:</p>

            <pre>
                uint8_t var[] = {"Hello World!"};
                HAL_UART_Transmit(&huart1, &var[0], 12, 100);
            </pre>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-9.png" />
              <p>Рисунок 19 Написание кода</p>
            </div>
            <p>
              Далее необходимо скомпилировать проект нажав кнопку "Build" с
              изображением молотка 🔨
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-10.png" />
              <p>Рисунок 20 Компиляция проекта</p>
            </div>
            <p>
              Если всё было успешно, то в консоли появится сообщение с
              содержанием как на рисунке ниже. В случае каких либо ошибок в
              консоли, необходимо найти причину этих ошибок и исправить их.
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-11.png" />
              <p>Рисунок 21 Сообщение об успешной компиляции</p>
            </div>
          </section>
          <section>
            <h3>Создание и настройка проекта в Proteus</h3>
            <p>Открыть среду Proteus. Кликнуть на "Schematic Capture".</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-1.png" />
              <p>Рисунок 22 Создание проекта в Proteus</p>
            </div>
            <p>
              Нажать кнопку "P" в английской раскладке клавиатуры, и ввести в
              строку поиска <b>STM32F401VE</b>.
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-2.png" />
              <p>Рисунок 23 Создание проекта в Proteus</p>
            </div>
            <p>Разместить микроконтроллер</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-3.png" />
              <p>Рисунок 24 STM32F401VE</p>
            </div>
            <p>
              Как было изучено ранее, микроконтроллер не способен визуально
              отображать данные, если не подключено никаких устройств для этого
              Поэтому необходимо подключить виртуальный терминал, на который по
              интерфейсу UART и будет осуществляться вывод заданного сообщения.
              Для этого в боковом меню выбрать virtual terminal
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-12.png" />
              <p>Рисунок 25 Виртуальный терминал</p>
            </div>
            <p>
              Подключить порт RX виртуального терминала к порту PB6
              микроконтроллера. Порт PB6 был назначен как UART TX порт при
              создании проекта в STM32CubeIDE
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-13.png" />
              <p>Рисунок 26 Виртуальный терминал</p>
            </div>
            <p>
              Для указания .hex файла для микроконтроллера, необходимо правой
              кнопкой мыши кликнуть по размещённой модели микроконтроллера и
              выбрать "Edit Properties"
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-14.png" />
              <p>Рисунок 27 Подключение hex файла</p>
            </div>
            <p>В поле "Program File" указать путь к hex файлу.</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-15.png" />
              <p>Рисунок 28 Подключение hex файла</p>
            </div>
            <p>
              Файл находится по пути, куда была установлена среда разработки
              STM32CubeIDE, либо там где был указн workspace. Возможный вариант
              STM32CubeIDE\workspace_1.7.0\Название проекта\Debug
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-16.png" />
              <p>Рисунок 29 Подключение hex файла</p>
            </div>
            <p>
              При создании проекта Baud Rate был указан с значением 115200,
              следовательно, чтобы виртуальный терминал принимал данные с той же
              скоростью, с которой их передаёт микроконтроллер, необходимо
              кликнуть правой кнопкой мышки по виртуальному терминалу и выбрать
              "Edit Properties", далее установить значение Baud Rate равным
              115200
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-17.png" />
              <p>Рисунок 30 Настройка виртуального терминал</p>
            </div>
            <p>Запустить симуляцию нажатием кнопки ▶</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-18.png" />
              <p>Рисунок 31 Запуск</p>
            </div>
            <p>
              Иногда виртуальный терминал может не появляться при запуске.
              Открыть его можно нажав Debug > Virtual Terminal
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-19.png" />
              <p>Рисунок 32 Запуск</p>
            </div>
            <p>
              На виртуальном терминале отображается сообщение "Hello World!"
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-20.png" />
              <p>Рисунок 33 Hello World</p>
            </div>
            <p>
              В ходе выполнения пункта "Введение" были приобретены навыки
              создания и настройки проекта в средах Proteus и STM32CubeIDE,
              получены навыки вывода заданного сообщения на виртуальный терминал
              по интерфейсу UART.
            </p>
          </section>
        </section>
      </section>
      <section id="testing">
        <h3>Принципы тестирования</h3>
        <p>
          Данный курс предполагает тестирование, чтобы в случае если сделана
          ошибка, можно было бы понять где именно.
        </p>
        <p>
          Чтобы реализовать тестирование необходимо добавить в схему модуль для
          передачи данных на comport
        </p>
        <p>
          Для этого нажать кнопку 'P' в английской раскладке на клавиатуре, и
          ввести в строку поиска 'COMPIM'
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/testing-1.png" />
          <p>Рисунок 34 Добавление COMPIM</p>
        </div>
        <p>
          Разместить на рабочем поле и подключить порт TXD к порту PB6
          микроконтроллера, по которому, через интерфейс UART осуществляется
          передача данных
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/testing-2.png" />
          <p>Рисунок 35 Добавление COMPIM</p>
        </div>
        <p>
          Теперь необходимо настроить модуль связи с виртуальным портом, если по
          каким-либо причинам компорты COM3 и COM4 заняты, то указать другие
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/testing-3.png" />
          <p>Рисунок 36 Настройка COMPIM</p>
        </div>
        <p>
          До запуска проекта в Proteus, необходимо запустить тест, для этого
          запустить файл test1.py, и следовать инструкциям в консоли. Так как в
          разделе "Введение" на виртуальный терминал выводилось сообщение "Hello
          World!", то в качестве ожидаемого результата необходимо ввести эту же
          эту фразу.
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/testing-4.png" />
          <p>Рисунок 37 Запуск теста</p>
        </div>
        <p>Теперь необходимо запустить симуляцию проекта в Proteus</p>
        <p>
          Если настройка выполнена правильно, то ожидается получение сообщения
          об успешном прохождении теста
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/testing-5.png" />
          <p>Рисунок 38 результат теста</p>
        </div>
        <p>
          Если было некорректно введено ожидаемое значение, либо при написании
          кода для микроконтроллера было записано сообщение с ошибкой, то будет
          получено соответствующее уведомление
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/testing-6.png" />
          <p>Рисунок 39 результат ошибочного теста</p>
        </div>
        <p>
          В таком случае необходимо исправить ошибку, и повторить перечисленные
          выше действия ещё раз, пока не будет получен положительный результат
          прохождения теста
        </p>
      </section>
      <section id="module1-1">
        <h3>
          Модуль 1.1. Арифметические операции с целыми беззнаковыми десятичными
          числами
        </h3>
        <h4>Задание</h4>
        <p>
          Выполнить математическое выражение и вывести результаты на виртуальный
          терминал
        </p>
        <p>
          A, B, C, D – целые беззнаковые десятичные числа от 5 до 20. <br />
          A > B > C > D
        </p>
        <ol class="math">
          <li>[4(A+B)-2(C+D)]∗3C<sup>2</sup></li>
          <li>(A∗B∗C-4B∗D)<sup>2</sup></li>
          <li>[(A−C)<sup>3</sup>+(B−D)<sup>2</sup>]∗D</li>
          <li>(A+B−C−D)∗(B−C)<sup>3</sup></li>
          <li>[(A−B)∗(B−C)∗(C−D)]<sup>2</sup></li>
          <li>A∗B∗D<sup>2</sup>−(5C−4D)</li>
          <li>[(A−B)<sup>3</sup>+C+D]∗(C−D)</li>
          <li>(7A−4B)∗C<sup>2</sup>−5D</li>
          <li>(A−C)∗(B−D)<sup>2</sup>∗(A−D)+4B</li>
          <li>(A<sup>3</sup>−5B<sup>2</sup>)∗(C−D)−D</li>
          <li>[A∗(C−D)+(B−C)<sup>2</sup>]∗B</li>
          <li>(A−B)∗(C<sup>3</sup>−4D<sup>2</sup>)+3C</li>
        </ol>
        <p>
          Аппаратную и программную часть можно использовать из раздела
          <a href="#introduction">"Введение"</a>, либо создать новый проект
        </p>
        <p>
          В разделе "Введение" были получены навыки вывода текстового сообщения.
          Однако теперь может возникнуть вопрос, как вывести значение числовой
          переменной?
        </p>
        <p>
          Для вывода необходимо записать значение переменной в буфер типа char.
          Потребуется подключить библиотеку stdio.h
        </p>
        <pre>#include "stdio.h"</pre>
        <p>
          Вывод чисел в формате float отключен по умолчанию, поэтому его надо
          включить
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/STM32-setting-project-step-1.png" />
          <p>
            Рисунок 40 Предупреждение о необходимости включить вывод чисел с
            плавающей запятой
          </p>
        </div>
        <p>
          Нажать Project > Properties , выбрать C/C++ Build > Setting, Далее MCU
          Settings и поставить галочку в поле "use float with pritf from
          newlib-nano". Нажать "Apply and Close"
        </p>
        <p>
          Пример вывода чисел в различных форматах. Вывод в бинарном формате не
          поддерживается по умолчанию, чтобы не усложнять задание предлагается
          выводить в шестнадцатеричном формате
        </p>
        <pre>
          char buffer[100];
          int example1 = 100;
          float example2 = 100.12345;
          int example3 = 0xA;
          int example4 = 0b1010;
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "integer %d\n\r", example1), 100);
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "float %f\n\r", example2), 100);
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "hex example 1 %x\n\r", example3), 100);
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "hex example 2 %x\n\r", example4), 100);
        </pre>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-1-prepare.png" />
          <p>Рисунок 41 Результаты вывода чисел в различных форматах</p>
        </div>
        <p>Выполнение задания.</p>
        <p>
          Пример: A = 10, B = 15, C = 17, D = 18 <br />
          Найти значение выражения <i>(A<sup>3</sup>∗(D-(C+B)<sup>4</sup>)</i>
        </p>
        <p>
          Для выполнения математических операций может потребоваться библиотека
          Math
        </p>
        <pre>#include "math.h"</pre>
        <p>
          В этом задании будет полезна функция pow(a,b) , с помощью неё можно
          возводить число a в степень b
        </p>
        <p>
          Были объявлены переменные A,B,C,D. Далее создана переменная result, в
          которую будет записан результат выражения.
        </p>
        <pre>
          char buffer[100];
          int A = 10;
          int B = 15;
          int C = 17;
          int D = 18;
          int result = pow(A,3)*(D-pow(C+B,4));
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%d\n\r", result), 100);</pre
        >
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-1-prepare-2.png" />
          <p>Рисунок 42 Результаты расчёта математического выражения</p>
        </div>
        <p>
          Операция проверки: A<sup>3</sup> = 10<sup>3</sup> = 1000, (C+B)<sup
            >4</sup
          >
          = (17+15)<sup>4</sup> = 32<sup>4</sup> = 1 048 576, D - (C+B)<sup
            >4</sup
          >
          = 18 - 1 048 576 = -1 048 558, (A<sup>3</sup>∗(D-(C+B)<sup>4</sup>) =
          1000 ∗ (-1 048 558) = -1 048 558 000
        </p>
        <p>
          По завершению операции проверки результата, можно убедиться, что
          результат посчитанный вручную совпадает с резульатом вычисленным
          микроконтроллером
        </p>
        <p>
          Для проверки корректности написанной программы, необходимо запустить
          тестирование, аналогично как в пункте "Тестирование". Далее нужно
          убедиться, что результат посчитан правильно, при необходимости
          произвести исправления, до положительного результата прохождения
          теста.
        </p>
      </section>
      <section id="module1-2">
        <h3>
          Модуль 1.2. Арифметические операции с рациональными десятичными
          числами
        </h3>
        <h4>Задание</h4>
        <p>
          Выполнить математическое выражение и вывести результаты на виртуальный
          терминал
        </p>
        <p>
          A, B, C, D, E – рациональные десятичные числа от -20 до +20.<br />A >
          B > C > 0; 0 > D > E (модуль E > модуля D)
        </p>
        <img src="./images/module_1/task1-2.png" />
        <!-- <ol class="math">
          <li><tex>$$\sqrt{C-A}*(D+E)^2\over{A+E}$$</tex></li>
          <li><tex>$$\sqrt[3]{C}+(B-A)^3\over{(D+E)^2}$$</tex></li>
          <li><tex>$$A^{2\over{3}}*(B-C)^2\over(D-E)$$</tex></li>
          <li><tex>$$(\log_B A + log_C B ) * \sqrt{D-E}$$</tex></li>
          <li><tex>$$\sqrt[3]{A-E}*log_D C + B^3 + E$$</tex></li>
          <li><tex>$$sin(B^{4\over{3}}+A*C^2-D*E)$$</tex></li>
          <li><tex>$$cos(\sqrt{A-(B-C)}+D-E)$$</tex></li>
          <li><tex>$$\log_C {(D+E^2+\sqrt[3]{A-B})\over{4C}}$$</tex></li>
          <li><tex>$$(A+B)^{2\over{3}}-\sqrt[3]{C-D}\over{2E}$$</tex></li>
          <li><tex>$$tan(0.35A*B+\sqrt{C+D^2}-E$$</tex></li>
          <li><tex>$$(log_C {(A+B)}-\sqrt{E^2+D})^2$$</tex></li>
          <li><tex>$$sin(\sqrt{C-A}*B)\over{(D+E)^2}$$</tex></li>
        </ol> -->
        <p>Полезными будут следующие функции библиотеки Math</p>
        <pre>
          sqrt(a) - возвращает квадратный корень числа a
          cbrt(a) - возвращает кубический корень числа a 
          sin(a), cos(a), tan(a) - возвращают синус, косинус и тангенс соответственно 
          log(a), log10(a) - возвращает натуральный и десятичный логарифмы соответственно
        </pre>
        <p>
          Чтобы вывести логарифм с определённым основание можно воспользоваться
          формулой замены основания логарифма
        </p>
        <img src="./images/module_1/task1-2-1.png" />
        <!-- <tex>$$log_A B = {log_C B\over{log_C A}}$$</tex> -->
        <p>Для этого была написана следующая функция</p>
        <pre>
          double logN(double base, double x) {
            return (double)(log(x) / log(base));
          }
        </pre>
        <p>
          Итого если необходимо получить логарифм с нужным основанием, то надо
          использовать написанную выше функцию
        </p>
        <pre>logN(a,b)</pre>
        <p>
          Пример. Пусть A = -10.43, B = -2.00325, C = 7.032, D = 11.999, E =
          17.124 <br />
          Рассчёт выражения:
          <!-- <tex>$${log_B C + \sqrt[3]{D+A}}\over{-E}$$</tex> -->
        </p>
        <img src="./images/module_1/task1-2-2.png" />
        <pre>
        char buffer[100];
        float A = 10.43;
        float B = 2.00325;
        float C = 7.032;
        float D = -11.999;
        float E = -17.124;
        float result = (logN(B,C)+cbrt(pow(D,4)-A/3))/(10*E);
        HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%f\n\r", result), 100);
        </pre>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-2-prepare-1.png" />
          <p>Рисунок 43 Результаты расчёта математического выражения</p>
        </div>
        <p>Выполнение проверки</p>
        <img src="./images/module_1/task1-2-3.png" />
        <!-- <tex
          >$$log_B C = 2.807359 , D+A = -1.569, -E = 17.124 , log_B C +
          \sqrt[3]{D+A} = -1.162004, {{log_B C + \sqrt[3]{D+A}}\over{-E}} =
          0.09608 $$</tex
        > -->
        <p>
          Результат оказался очень близок, разница из-за погрешности вычислений
        </p>
        <p>
          Запустить тестирование убедиться, что результат посчитан правильно,
          при необходимости сделать исправления.
        </p>
      </section>
      <section id="module1-3">
        <h3>Модуль 1.3. Логические операции</h3>
        <h4>Задание</h4>
        <p>
          Выполнить логическое выражение и вывести результаты на виртуальный
          терминал
        </p>
        <p>
          A, B, C, D – четырёхразрядные двоичные логические переменные от 0000
          до 1111.
        </p>
        <p>Обозначение операций</p>
        <ul>
          <li>
            ⊕ -
            <a
              href="https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%C2%AB%D0%B8%D0%BB%D0%B8%C2%BB"
              >исключающее ИЛИ</a
            >
            (суммирование по модулю 2 )
          </li>
          <li>
            ≡ -
            <a
              href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B5%D0%BD%D1%86%D0%B8%D1%8F"
              >функция равнозначности </a
            >(инверсия от исключающего ИЛИ)
          </li>
          <li>
            | -
            <a
              href="https://ru.wikipedia.org/wiki/%D0%A8%D1%82%D1%80%D0%B8%D1%85_%D0%A8%D0%B5%D1%84%D1%84%D0%B5%D1%80%D0%B0"
              >штрих Шеффера</a
            >
            (И-НЕ)
          </li>
          <li>
            ↓ –
            <a
              href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B5%D0%BB%D0%BA%D0%B0_%D0%9F%D0%B8%D1%80%D1%81%D0%B0"
              >стрелка Пирса</a
            >
            (ИЛИ-НЕ)
          </li>
        </ul>
        <img src="./images/module_1/task1-3-0.png" />
        <!-- <ol class="math">
          <li><tex>$$(A + \bar{B}) + (\bar C \oplus D)$$</tex></li>
          <li><tex>$$\overline{A*\bar C} \oplus (B + \bar D) $$</tex></li>
          <li><tex>$$\overline{(A+D)}*(B \oplus \bar C)$$</tex></li>
          <li><tex>$$\overline{(B+C+D)}*\overline{(\bar A*B)}$$</tex></li>
          <li><tex>$$B*\bar C*D*(A \oplus C)$$</tex></li>
          <li><tex>$$A↓C+(B|\bar D)$$</tex></li>
          <li><tex>$$A*B \equiv (A+C+D)$$</tex></li>
          <li><tex>$$(A+\bar B)↓(A+C*D)$$</tex></li>
          <li><tex>$$(A \equiv C)+B*(C|D)$$</tex></li>
          <li><tex>$$(C+D)|(A \oplus \bar B)$$</tex></li>
          <li><tex>$$A*B*(C+D)↓ \bar D$$</tex></li>
          <li><tex>$$\bar A \equiv \overline{(B+\bar C + D)}$$</tex></li>
        </ol> -->
        <p>
          Ниже приведены логические операторы, с помощью которых можно
          реализовать операции
        </p>
        <pre>
          A & B - логическое И
          A | B - логическое ИЛИ
          ~A - логическое отрицание
          A ^ B - исключающее или
        </pre>
        <p>
          Остальные логические операции можно реализовать с помощью приведенных
          выше, создав следующие логические функции
        </p>
        <pre>
          int NAND(int a, int b) {
            return ~(a&b);
          }
        
          int NOR(int a, int b) {
            return ~(a|b);
          }
        </pre>
        <p>
          Пример. A = 0b1010; B = 0b1011; C = 0b1100; D = 0b1101, выражение:
          <!-- $$\bar A*(D↓C)+(C|B)$$ -->
        </p>
        <img src="./images/module_1/task1-3-1.png" />
        <pre>
          char buffer[100];
          int A = 0b1010;
          int B = 0b1011;
          int C = 0b1100;
          int D = 0b1101;
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%x\n\r",((~A&NAND(D,C))|NOR(C,B))&0xF), 100);
        </pre>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-3-prepare.png" />
          <p>Рисунок 44 Результаты расчёта логического выражения</p>
        </div>
        <p>Выполнение проверки</p>
        <img src="./images/module_1/task1-3-2.png" />
        <!-- <tex
          >$$\bar A = 0b0101, (D↓C) = 0b0011, \bar A*(D↓C) = 0b0001, (C|B) =
          0b0000, \bar A*(D↓C)+(C|B) = 0b0001 $$</tex
        > -->
        <p>
          Как видно, полученный результат идентичен результату, который посчитан
          на микроконтроллере
        </p>
        <p>
          Запустить тестирование убедиться, что результат посчитан правильно,
          при необходимости сделать исправления
        </p>
      </section>
      <section id="module1-4">
        <h3>Модуль 1.4. Запись в память</h3>
        <h4>Задание 1.4.1</h4>
        <p>
          Записать в память свои имя и фамилию с помощью ASCII кодов, начиная с
          адреса, соответствующего трём последним цифрам номера телефона. Запись
          сделать в flash память, не раньше ячейки 08002000, чтобы избежать
          перезаписывания кода программы
        </p>
        <p><a href="https://www.ascii-code.com/">Таблица ASCII кодов</a></p>
        <p>
          Для записи в flash память, необходима её разблокировка, делается это
          командой HAL_FLASH_Unlock(), запись в память осуществляется командой
          HAL_FLASH_Program
        </p>
        <p>
          В приведенном ниже фрагменте программы, в память осуществляется запись
          слов "MY NAME"
        </p>
        <pre>
          HAL_FLASH_Unlock();
          uint8_t wrBuf[7] = {77, 89, 32, 78, 65, 77, 69 };
          uint32_t flashAddress = 0x08002000;
          for(uint32_t i=0; i<7; i++)
          {
              HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, flashAddress, ((uint8_t *)wrBuf)[i]);
              flashAddress++;
          }
          HAL_FLASH_Lock();
        </pre>
        <p>
          Чтобы посмотреть результат записи, в Proteus нажать Debug > CM4 >
          FLASH at 0x08000000
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-4-prepare-1.png" />
          <p>Рисунок 45 Открытие окна просмотра памяти</p>
        </div>
        <p>
          Далее либо промотать ползунок прокрутки до нужной ячейки, либо
          кликнуть правой кнопкой мыши и выбрать "Go to" , далее ввести нужный
          адрес в соответсвии с вариантом
        </p>
        <p>Слово записанное тестовой программой</p>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-4-prepare-2.png" />
          <p>Рисунок 36 Записанное слово в памяти</p>
        </div>
        <p>Как видно, в памяти записано слово "MY NAME"</p>
        <p>
          Для того, чтобы сделать тестирование, необходимо добавить одну строчку
          в цикл записи в память. Для этого необходимо создать ещё одну
          переменную для буфера
        </p>
        <pre>
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%d", ((uint8_t *)wrBuf)[i]), 100);
        </pre>
        <h4>Задание 1.4.2</h4>
        <p>
          Усложнение задачи. Необходимо написать функцию, которая вычисляет
          <a
            href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8"
            >числа Фибоначчи</a
          >
          до 30. Для удобства просмотра, в памяти можно сделать запись через 17
          ячеек.
        </p>
        <p>
          Для чётных вариантов сделать вычисление числа Фибоначчи по формуле
          Бине, для нечётных реализовать линейный алгоритм нахождения
        </p>
        <p>
          * Задание повышенной сложности: реализовать вычисление числа Фибоначчи
          <a
            href="http://mech.math.msu.su/~shvetz/54/inf/perl-problems/chFibonacci_sIdeas.xhtml#:~:text=%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%20%D1%8D%D1%82%D0%BE%D0%B3%D0%BE%20%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%BB%D0%B0.-,%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F,-%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B"
            >матричным способом</a
          >
        </p>
        <p>Формула Бине:</p>
        <img src="./images/module_1/task1-4-1.png" />
        <!-- <p>
          $$F_{n} = {{{(1+\sqrt{5})^n\over{2}} -
          {(1-\sqrt{5})^n\over{2}}}\over{\sqrt{5}}}$$
        </p> -->
        <p>Линейный алгоритм</p>
        <img src="./images/module_1/task1-4-2.png" />
        <!-- <p>$$F_{n} = F_{n-1} + F_{n-2}$$</p>
        <p>$$F_{0} = 0, F_{1} = 1$$</p> -->
        <p>
          Функцию для вычисления числа Фибоначчи необходимо реализовать
          самостоятельно
        </p>
        <p>
          Возможно, при решении данной задачи, может быть непонятно почему после
          15-го числа, ответ отображается неверно. Ответ прост: одна ячейка
          памяти равна байту, число записывается в память начиная с младшего
          байта
        </p>
        <p>Для лучшего понимания был рассмотрен пример ниже</p>
        <pre>
HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, flashAddress, 0x78563412);</pre
        >
        <p>Как видно из кода в память записывается число 0x78563412</p>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-4-2prepare1.png" />
          <p>Рисунок 47 Запись в память 32х разрядного числа</p>
        </div>
        <p>
          Сначала был записан младший байт - 12, далее следующий по старшинству
          - 34, далее 56 и в конце 78, в итоге было получено 12345678
        </p>
        <p>Итоговый результат представлен на рисунке ниже</p>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-4-2prepare2.png" />
          <p>Рисунок 48 Запись в память чисел Фибоначчи</p>
        </div>
        <p>
          Сделать тестирование, для вариантов где вычислялось по формуле Бине,
          вывод на UART сделать в виде чисел в формате float
        </p>
      </section>
    </div>
  </body>
</html>
