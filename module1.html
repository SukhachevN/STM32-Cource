<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <!-- <script
      type="text/javascript"
      async
      src="/MathJax/MathJax.js?config=TeX-MML-AM_CHTML"
    ></script> -->
    <title>Методические указания.</title>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Модуль 1</h1>
        <h2>Содержание</h2>
        <nav>
          <ol>
            <li><a href="#introduction">Введение</a></li>
            <li>
              <a href="#module1-1"
                >Арифметические операции с целыми беззнаковыми десятичными
                числами</a
              >
            </li>
            <li>
              <a href="#module1-2"
                >Арифметические операции с рациональными десятичными числами</a
              >
            </li>
            <li><a href="#module1-3">Логические операции</a></li>
            <li><a href="#module1-4">Заполнение памяти</a></li>
          </ol>
        </nav>
      </header>
      <section id="introduction">
        <h2>Введение</h2>
        <section>
          <h3>Теоретическая часть</h3>
          <h4>Немного о STM32</h4>
          <p>
            STM32 — семейство 32-битных микроконтроллеров производства
            STMicroelectronics. Чипы STM32 группируются в серии, в рамках каждой
            из которых используется одно и то же 32-битное ядро ARM
          </p>
          <p>
            Каждый микроконтроллер состоит из ядра процессора, статической
            RAM-памяти, флеш-памяти, отладочного и различных периферийных
            интерфейсов.
          </p>
          <p>
            Семейство микроконтроллеров STM32 состоит из 16 серий: F0, F1, F2,
            F3, F4, F7, L0, L1, L4, L4+, L5, G0, G4, H7, WB, WL
          </p>
          <p>Сама компания STM делит на все серии 4 группы</p>
          <ul>
            <li>Высокопроизводительные - F2, F4, F7, H7</li>
            <li>Широкого применения - F0, G0, F1, F3, G4</li>
            <li>Сверхнизкого потребления - L0, L1, L4, L4+, L5</li>
            <li>Беспроводные - WB, WL</li>
          </ul>
          <h4>STM32F401VE</h4>
          <p>
            В курсе лабораторных работ основным микроконтроллером с которым
            будем работать будет модель STM32F401VE с ядром CORTEX-M4
          </p>
          <p>
            Этот микроконтроллер изначально доступен в среде Proteus 8.9, и не
            требует дополнительной установки каких либо пакетов
          </p>
          <p>Перейдём к рассмотрению технических характеристик. Итого имеем:</p>
          <p>Ядро:</p>
          <ul>
            <li>ARM®32-bit Cortex®-M4 CPU with FPU</li>
            <li>
              ART Accelerator ™, позволяющий выполнять операции с нулевым
              ожиданием из флэш-памяти
            </li>
            <li>Частота работы до 84 МГц</li>
            <li>Блок защиты памяти</li>
            <li>Инструкции DSP (digital signal processor)</li>
          </ul>
          <p>Память:</p>
          <ul>
            <li>512 КБайт FLASH памяти</li>
            <li>96 Кбайт SRAM памяти</li>
          </ul>
          <p>Тактиррование, и питание:</p>
          <ul>
            <li>Напряжение портов ввода/вывода от 1.7 V до 3.6 V</li>
            <li>
              <p>POR, PDR, PVD и BOR</p>
              <p>
                BOR (Brownout Reset) это блок, который сохраняет состояние
                сброса микроконтроллера для тех пор, пока напряжение питания не
                достигнет заданного порогового значения VBOR. VBOR настраивается
                через Option bytes микроконтроллера. По умолчанию BOR выключен.
                Пользователь может выбрать от трех до пяти программируемых
                пороговых значений VBOR.
              </p>
              <p>
                POR (Power On Reset)/PDR (Power Down Reset), выполняет ту же
                операцию, что и BOR, но с фиксированным и, настроенным на
                заводе, пороговым значением напряжения.
              </p>
              <p>
                Прошивка устройства может активно контролировать электропитание
                с помощью программируемого детектора напряжения PVD
                (Programmable Voltage Detector). PVD позволяет настроить
                напряжение для мониторинга, и если это напряжение VDD выше или
                ниже заданного уровня, то устанавливается соответствующий бит в
                регистре управления питанием
              </p>
            </li>
            <li>Кварцевый генератор от 4 до 26 МГц</li>
            <li>Генератор 2 кГц для RTC(real time clock) с калибровкой.</li>
          </ul>
          <p>Потребляемая мощность:</p>
          <ul>
            <li>
              В режиме работе: 146 мкА / МГц , при условии, что перефирийные
              устройства отключены
            </li>
            <li>
              В режиме остановки (Flash в режиме остановки, быстрое
              пробуждение): от 42 до 62 мкА
            </li>
            <li>
              В режиме остановки (Flash в режиме глубокого сна, быстрое
              пробуждение): : от 10 до 30 мкА
            </li>
            <li>В режиме ожидания: 2,4 мкА (без RTC)</li>
            <li>Питание VBAT для RTC: 1 мкА</li>
          </ul>
          <p>
            1 × 12-битный аналого-цифровой преобразователь 2,4 MSPS: до
            16каналов
          </p>
          <p>
            Универсальный DMA: 16-потоковый DMA с FIFO и пакетной поддержкой.
            DMA - direct memory access
          </p>
          <p>
            До 11 таймеров: 6 × 16-битных, 2 × 32-битных таймера до 84 МГц, в
            каждом до четырех IC(Input Capture) / OC(Output Compare) / PWM или
            счетчик импульсов и квадратура (инкрементальный) вход энкодера, два
            watchdog (сторожевых таймера) таймера и таймер SysTick
          </p>
          <p>Режим отладки</p>
          <ul>
            <li>Serial wire debug (SWD) & JTAG interfaces</li>
            <li>Cortex®-M4 Embedded Trace Macrocell™</li>
          </ul>
          <p>81 порт ввода/вывода</p>
          <p>12 интерфейсов связи</p>
          <ul>
            <li>3 × I<sup>2</sup>C</li>
            <li>3 × USART ( 2 × 10.5 Мбит/с, 1 × 5.25 Мбит/c</li>
            <li>4 × SPI (42 Мбит/с fCPU = 84 МГц)</li>
            <li>1 × SDIO</li>
            <li>1 × SDIO</li>
          </ul>
          <p>Устройство расчёта циклического избыточного кода (CRC unit)</p>
          <p>96 бит уникального ID</p>
          <p>RTC: субсекундная точность, аппаратный календарь</p>
          <p>Работа при температуре от –40 to +105 °C</p>
          <p>
            Всё выше перечисленное позволяет применять микроконтроллер
            STM32F401VE во многих областях:
          </p>
          <ul>
            <li>Управление моторным приводом</li>
            <li>Медицинское оборудование</li>
            <li>
              Промышленное применение: программируемые логические контроллеры,
              инверторы , автоматические выключатели
            </li>
            <li>Принтеры, сканеры</li>
            <li>
              Системы сигнализации, видеодомофоны, HVAC (Heating, Ventilation, &
              Air Conditioning - отопление, вентиляция, кондиционирование)
            </li>
            <li>Бытовая аудиотехника</li>
            <li>Сенсорный концентратор мобильного телефона</li>
          </ul>
          <div class="imageBlock">
            <img src="./images/module_1/structure-scheme.png" />
            <p>Рисунок 1 структурная схема STM32F401VE</p>
          </div>
          <div class="imageBlock">
            <img src="./images/module_1/IO-scheme.png" />
            <p>Рисунок 2 выводы STM32F401VE</p>
          </div>
        </section>
        <section>
          <h3>Практическая часть</h3>
          <p>
            В этом разделе познакомимся с созданием и настройкой своего первого
            проекта на основе ARM микроконтроллера семейства Cortex-M4
          </p>
          <p>
            Напишем простую программу "Hello World!". Чтобы сделать это
            необходимо создать 2 части : программную - написать код в
            STM32CubeIDE, и аппаратную, создать схему в Proteus
          </p>
          <section>
            <h3>Создание и настройка проекта в STM32CubeIDE</h3>
            <p>Откроем STM32CubeIDE. Выбираем File > New > STM32 Project</p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-1.png" />
              <p>Рисунок 3 Создание проекта в STM32CubeIDE</p>
            </div>
            <p>
              Далее в поле "Part number" вводим <b>STM32F401VE</b>. Кликаем на
              название в списке и жмём "Next"
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-2.png" />
              <p>Рисунок 4 Выбор модели микроконтроллера в STM32CubeIDE</p>
            </div>
            <p>Вводим имя для проекта и нажимаем "Finish"</p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-3.png" />
              <p>Рисунок 5 Название проекта</p>
            </div>
            <p>
              Включим тактирование. Для этого в правом боковом меню выбираем
              "RCC". В поле "High Speed Clock" выбираем "Crystal/Ceramic
              Resonator"
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-4.png" />
              <p>Рисунок 6 настройка тактирования</p>
            </div>
            <p>
              Сам по себе микроконтроллер не может визуально отображать данные.
              Чтобы решить эту проблему, будем передавать данные по
              <a href="#UART">UART</a>. Однако по умолчанию он выключен в
              микроконтроллере, поэтому давайте включим его.
            </p>
            <p>
              В правом левом меню перейдём в раздел "Connectivity". Здесь видим
              список всего того, что можно подключить к микроконтроллеру.
              Выбираем "USART1". В поле Mode выбираем "Asynchronous". Также
              стоит обратить внимание на настройки UART, Видим что по умолчанию
              Baud Rate установлен 115200. Это количество бит передаваемых
              микроконтроллером по UART за 1 секунду
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-5.png" />
              <p>Рисунок 7 настройка UART</p>
            </div>
            <p>
              После того как включили UART на pinout можно увидеть на какие
              порты назначен UART. Это порты PB6(RX) и PB7(TX). RX - для
              передачи, TX - для приёма.
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-6.png" />
              <p>Рисунок 8 Pinout</p>
            </div>
            <p>
              Теперь наш проект настроен. Можно переходить к генерации кода. Да,
              полностью с нуля писать код для микроконтроллера не нужно,
              STM32CubeIDE сгенерирует базовый код в соответствии с указанными
              настройками. Для генерации кода нажимаем кнопку "Build" с
              изображением молотка 🔨. Далее нажимаем "yes" во всех появляющихся
              окнах.
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-7.png" />
              <p>Рисунок 9 Генерация кода</p>
            </div>
            <p>
              Перед тем как начать писать код настроим компиляцию. Для этого
              перейдём Project > Properties
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-8-2.png" />
              <p>Рисунок 10 Настройка проекта</p>
            </div>
            <p>
              В появившемся окне выбираем C/C++ Build > Setting . Далее кликаем
              на "MCU Post build outputs". Ставим галочку в поле "Convert to
              Intel Hex file (-O ihex)". Эта опция нужна чтобы генерировать hex
              файл, который нужен для симуляции в Proteus
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-8.png" />
              <p>Рисунок 11 Настройка проекта</p>
            </div>
            <p>
              Перейдём непосредственно к написанию кода. Объявим переменную var
              как массив и запишем в него строку "Hello World!". Чтобы передать
              данную строку по UART используем библиотечную функцию
              HAL_UART_Transmit. Она принимает как параметры: модуль uart по
              которому хотим передавать данные (при настройке был выбран uart1),
              указатель на буффер данных, размер данных ( в нашем случае 12 это
              длина строки "Hello World!"), и длительность timeout
            </p>
            <p>Итого необходимо добавить 2 строки в свой код:</p>

            <pre>
                uint8_t var[] = {"Hello World!"};
                HAL_UART_Transmit(&huart1, &var[0], 12, 100);
            </pre>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-9.png" />
              <p>Рисунок 12 Написание кода</p>
            </div>
            <p>Скомпилируем проект нажав кнопку "Build" 🔨</p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-10.png" />
              <p>Рисунок 13 Компиляция проекта</p>
            </div>
            <p>
              Если всё было успешно, то в консоли увидите сообщение примерно
              следующего содержания. В случае каких либо ошибок в консоли,
              следует исправить их.
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/STM32-create-project-step-11.png" />
              <p>Рисунок 14 Сообщение об успешной компиляции</p>
            </div>
          </section>
          <section>
            <h3>Создание и настройка проекта в Proteus</h3>
            <p>Откроем Proteus. Кликаем на "Schematic Capture".</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-1.png" />
              <p>Рисунок 15 Создание проекта в Proteus</p>
            </div>
            <p>
              Нажимаем кнопку "P" и вводим в строку поиска <b>STM32F401VE</b>.
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-2.png" />
              <p>Рисунок 16 Создание проекта в Proteus</p>
            </div>
            <p>Размещаем.</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-3.png" />
              <p>Рисунок 17 STM32F401VE</p>
            </div>
            <p>
              Уже знаем что микроконтроллер сам по себе не может визуально
              отобразить данные. Поэтому подключим виртуальный терминал, на
              который по UART и выведем сообщение. Для этого в боковом меню
              выбираем virtual terminal
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-12.png" />
              <p>Рисунок 18 Виртуальный терминал</p>
            </div>
            <p>
              Подключаем вход RX к порту PB6. Именно этот порт был назначен как
              UART RX порт при создании проекта в STM32CubeIDE
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-13.png" />
              <p>Рисунок 19 Виртуальный терминал</p>
            </div>
            <p>
              Укажем hex файла для микроуонтроллера, для этого правой кнопкой
              мыши кликнем по нему и выберем "Edit Properties"
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-14.png" />
              <p>Рисунок 20 Подключение hex файла</p>
            </div>
            <p>В поле "Program File" указывем путь к hex файлу</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-15.png" />
              <p>Рисунок 21 Подключение hex файла</p>
            </div>
            <p>
              Файл находится по пути куда установили STM32CubeIDE, либо там где
              указали workspace . Примерно STM32CubeIDE\workspace_1.7.0\Название
              проекта\Debug
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-16.png" />
              <p>Рисунок 22 Подключение hex файла</p>
            </div>
            <p>
              Также помним что Baud Rate в настройках был указан как 115200
              бит/c, поэтому установим соответствующее значения для виртуального
              терминала точно также нажав "Edit Properties" и поменяв
              соответствующее поле
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-17.png" />
              <p>Рисунок 23 Настройка виртуального терминал</p>
            </div>
            <p>Запускаем нажав кнопку ▶</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-18.png" />
              <p>Рисунок 24 Запуск</p>
            </div>
            <p>
              Иногда виртуальный терминал может не появляться при запуске.
              Открыть его можно нажав Debug > Virtual Terminal
            </p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-19.png" />
              <p>Рисунок 25 Запуск</p>
            </div>
            <p>Видим сообщение "Hello World!" на виртуальном терминале</p>
            <div class="imageBlock">
              <img src="./images/module_1/Proteus-create-project-step-20.png" />
              <p>Рисунок 26 Hello World</p>
            </div>
            <p>
              Подведём итоги. В ходе выполнения пункта "Введение" приобрели
              навыки создания и настройки проекта в средах Proteus и
              STM32CubeIDE, научились выводить сообщение на виртуальный терминал
              по UART.
            </p>
          </section>
        </section>
      </section>
      <section id="module1-1">
        <h3>
          Модуль 1.1. Арифметические операции с целыми беззнаковыми десятичными
          числами
        </h3>
        <h4>Задание</h4>
        <p>
          Выполнить математическое выражение и вывести результаты на виртуальный
          терминал
        </p>
        <p>
          A, B, C, D – целые беззнаковые десятичные числа от 5 до 20. <br />
          A > B > C > D
        </p>
        <ol class="math">
          <li>[4(A+B)-2(C+D)]∗3C<sup>2</sup></li>
          <li>(A∗B∗C-4B∗D)<sup>2</sup></li>
          <li>[(A−C)<sup>3</sup>+(B−D)<sup>2</sup>]∗D</li>
          <li>(A+B−C−D)∗(B−C)<sup>3</sup></li>
          <li>[(A−B)∗(B−C)∗(C−D)]<sup>2</sup></li>
          <li>A∗B∗D<sup>2</sup>−(5C−4D)</li>
          <li>[(A−B)<sup>3</sup>+C+D]∗(C−D)</li>
          <li>(7A−4B)∗C<sup>2</sup>−5D</li>
          <li>(A−C)∗(B−D)<sup>2</sup>∗(A−D)+4B</li>
          <li>(A<sup>3</sup>−5B<sup>2</sup>)∗(C−D)−D</li>
          <li>[A∗(C−D)+(B−C)<sup>2</sup>]∗B</li>
          <li>(A−B)∗(C<sup>3</sup>−4D<sup>2</sup>)+3C</li>
        </ol>
        <p>
          Аппаратную и программную часть можно использовать из раздела
          <a href="#introduction">"Введение"</a>, либо при желании создать новый
          проект и попробовать самостоятельно
        </p>
        <p>
          В разделе "Введение" уже научились выводить. Но как вывести значение
          переменной?
        </p>
        <p>
          Для вывода необходимо записать значение переменной в буффер типа char.
          Потребуется подключить библиотеку stdio.h
        </p>
        <pre>#include "stdio.h"</pre>
        <p>
          Вывод чисел в формате float отключен по умолчанию, поэтому его надо
          включить
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/STM32-setting-project-step-1.png" />
          <p>
            Рисунок 27 Предупреждение о необходимости вкдчить вывод чисел с
            плавающей запятой
          </p>
        </div>
        <p>
          Нажимаем Project > Properties , выбираем C/C++ Build > Setting, Далее
          MCU Settings и ставим галочку в поле "use float with pritf from
          newlib-nano". Жмём "Apply and Close"
        </p>
        <p>
          Пример вывода чисел в различных форматах. Вывод в бинарном формате не
          поддерживается по умолчанию, чтобы не усложнять задание предлагается
          выводить в шестнадцатеричном формате
        </p>
        <pre>
          char buffer[100];
          int example1 = 100;
          float example2 = 100.12345;
          int example3 = 0xA;
          int example4 = 0b1010;
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "integer %d\n\r", example1), 100);
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "float %f\n\r", example2), 100);
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "hex example 1 %x\n\r", example3), 100);
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "hex example 2 %x\n\r", example4), 100);
        </pre>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-1-prepare.png" />
          <p>Рисунок 28 Результаты вывода чисел в различных форматах</p>
        </div>
        <p>Теперь можно перейти к выполнению задания.</p>
        <p>
          Рассмотрим пример: A = 10, B = 15, C = 17, D = 18 <br />
          Найти значение выражения <i>(A<sup>3</sup>∗(D-(C+B)<sup>4</sup>)</i>
        </p>
        <p>
          Для выполнения математических операций может потребоваться библиотека
          Math
        </p>
        <pre>#include "math.h"</pre>
        <p>
          В этом задании будет полезна функция pow(a,b) , которая возводит число
          a в степень b
        </p>
        <p>
          Вернёмся к примеру. Объявим переменные A,B,C,D. Далее создадим
          переменную result в которую запишем результат выражения.
        </p>
        <pre>
          char buffer[100];
          int A = 10;
          int B = 15;
          int C = 17;
          int D = 18;
          int result = pow(A,3)*(D-pow(C+B,4));
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%d\n\r", result), 100);</pre
        >
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-1-prepare-2.png" />
          <p>Рисунок 29 Результаты расчёта математического выражения</p>
        </div>
        <p>
          Давайте проверим: A<sup>3</sup> = 10<sup>3</sup> = 1000, (C+B)<sup
            >4</sup
          >
          = (17+15)<sup>4</sup> = 32<sup>4</sup> = 1 048 576, D - (C+B)<sup
            >4</sup
          >
          = 18 - 1 048 576 = -1 048 558, (A<sup>3</sup>∗(D-(C+B)<sup>4</sup>) =
          1000 ∗ (-1 048 558) = -1 048 558 000
        </p>
        <p>
          Как видим полученный результат совпал с результатом посчитанным
          микроконтроллером
        </p>
      </section>
      <section id="module1-2">
        <h3>
          Модуль 1.2. Арифметические операции с рациональными десятичными
          числами
        </h3>
        <h4>Задание</h4>
        <p>
          Выполнить математическое выражение и вывести результаты на виртуальный
          терминал
        </p>
        <p>
          A, B, C, D, E – рациональные десятичные числа от -20 до +20.<br />A >
          B > C > 0; 0 > D > E (модуль E > модуля D)
        </p>
        <img src="./images/module_1/task1-2.png" />
        <!-- <ol class="math">
          <li><tex>$$\sqrt{C-A}*(D+E)^2\over{A+E}$$</tex></li>
          <li><tex>$$\sqrt[3]{C}+(B-A)^3\over{(D+E)^2}$$</tex></li>
          <li><tex>$$A^{2\over{3}}*(B-C)^2\over(D-E)$$</tex></li>
          <li><tex>$$(\log_B A + log_C B ) * \sqrt{D-E}$$</tex></li>
          <li><tex>$$\sqrt[3]{A-E}*log_D C + B^3 + E$$</tex></li>
          <li><tex>$$sin(B^{4\over{3}}+A*C^2-D*E)$$</tex></li>
          <li><tex>$$cos(\sqrt{A-(B-C)}+D-E)$$</tex></li>
          <li><tex>$$\log_C {(D+E^2+\sqrt[3]{A-B})\over{4C}}$$</tex></li>
          <li><tex>$$(A+B)^{2\over{3}}-\sqrt[3]{C-D}\over{2E}$$</tex></li>
          <li><tex>$$tan(0.35A*B+\sqrt{C+D^2}-E$$</tex></li>
          <li><tex>$$(log_C {(A+B)}-\sqrt{E^2+D})^2$$</tex></li>
          <li><tex>$$sin(\sqrt{C-A}*B)\over{(D+E)^2}$$</tex></li>
        </ol> -->
        <p>Полезными будут следующие функции библиотеки Math</p>
        <pre>
          sqrt(a) - возвращает квадратный корень числа a
          cbrt(a) - возвращает кубический корень числа a 
          sin(a), cos(a), tan(a) - возвращают синус, косинус и тангенс соответственно 
          log(a), log10(a) - возвращает натуральный и десятичный логарифмы соответственно
        </pre>
        <p>
          Чтобы вывести логарифм с определённым основание воспользуемся формулой
          замены основания логарифма
        </p>
        <img src="./images/module_1/task1-2-1.png" />
        <!-- <tex>$$log_A B = {log_C B\over{log_C A}}$$</tex> -->
        <p>
          Напишем простую функцию для получения логарифма с нужным основанием
        </p>
        <pre>
          double logN(double base, double x) {
            return (double)(log(x) / log(base));
          }
        </pre>
        <p>
          Итого если хотим получить логаримф с нужным основанием просто
          используем написанную функцию
        </p>
        <pre>logN(a,b)</pre>
        <p>
          Рассмотрим пример. Пусть A = -10.43, B = -2.00325, C = 7.032, D =
          11.999, E = 17.124 <br />
          Рассчитаем выражение:
          <!-- <tex>$${log_B C + \sqrt[3]{D+A}}\over{-E}$$</tex> -->
        </p>
        <img src="./images/module_1/task1-2-2.png" />
        <pre>
        char buffer[100];
        float A = 10.43;
        float B = 2.00325;
        float C = 7.032;
        float D = -11.999;
        float E = -17.124;
        float result = (logN(B,C)+cbrt(pow(D,4)-A/3))/(10*E);
        HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%f\n\r", result), 100);
        </pre>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-2-prepare-1.png" />
          <p>Рисунок 30 Результаты расчёта математического выражения</p>
        </div>
        <p>Выполним проверку</p>
        <img src="./images/module_1/task1-2-3.png" />
        <!-- <tex
          >$$log_B C = 2.807359 , D+A = -1.569, -E = 17.124 , log_B C +
          \sqrt[3]{D+A} = -1.162004, {{log_B C + \sqrt[3]{D+A}}\over{-E}} =
          0.09608 $$</tex
        > -->
        <p>Результат очень близок, разница из-за погрешности вычислений</p>
      </section>
      <section id="module1-3">
        <h3>Модуль 1.3. Логические операции</h3>
        <h4>Задание</h4>
        <p>
          Выполнить логическое выражение и вывести результаты на виртуальный
          терминал
        </p>
        <p>
          A, B, C, D – четырёхразрядные двоичные логические переменные от 0000
          до 1111.
        </p>
        <p>Обозначение операций</p>
        <ul>
          <li>
            ⊕ -
            <a
              href="https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%C2%AB%D0%B8%D0%BB%D0%B8%C2%BB"
              >исключающее ИЛИ</a
            >
            (суммирование по модулю 2 )
          </li>
          <li>
            ≡ -
            <a
              href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B5%D0%BD%D1%86%D0%B8%D1%8F"
              >функция равнозначности </a
            >(инверсия от исключающего ИЛИ)
          </li>
          <li>
            | -
            <a
              href="https://ru.wikipedia.org/wiki/%D0%A8%D1%82%D1%80%D0%B8%D1%85_%D0%A8%D0%B5%D1%84%D1%84%D0%B5%D1%80%D0%B0"
              >штрих Шеффера</a
            >
            (И-НЕ)
          </li>
          <li>
            ↓ –
            <a
              href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B5%D0%BB%D0%BA%D0%B0_%D0%9F%D0%B8%D1%80%D1%81%D0%B0"
              >стрелка Пирса</a
            >
            (ИЛИ-НЕ)
          </li>
        </ul>
        <img src="./images/module_1/task1-3-0.png" />
        <!-- <ol class="math">
          <li><tex>$$(A + \bar{B}) + (\bar C \oplus D)$$</tex></li>
          <li><tex>$$\overline{A*\bar C} \oplus (B + \bar D) $$</tex></li>
          <li><tex>$$\overline{(A+D)}*(B \oplus \bar C)$$</tex></li>
          <li><tex>$$\overline{(B+C+D)}*\overline{(\bar A*B)}$$</tex></li>
          <li><tex>$$B*\bar C*D*(A \oplus C)$$</tex></li>
          <li><tex>$$A↓C+(B|\bar D)$$</tex></li>
          <li><tex>$$A*B \equiv (A+C+D)$$</tex></li>
          <li><tex>$$(A+\bar B)↓(A+C*D)$$</tex></li>
          <li><tex>$$(A \equiv C)+B*(C|D)$$</tex></li>
          <li><tex>$$(C+D)|(A \oplus \bar B)$$</tex></li>
          <li><tex>$$A*B*(C+D)↓ \bar D$$</tex></li>
          <li><tex>$$\bar A \equiv \overline{(B+\bar C + D)}$$</tex></li>
        </ol> -->
        <p>
          Ниже приведены логические операторы, с помощью которых можно
          реализовать операции
        </p>
        <pre>
          A & B - логическое И
          A | B - логическое ИЛИ
          ~A - логическое отрицание
          A ^ B - исключающее или
        </pre>
        <p>
          Остальные логические операции можно реализовать с помощью приведенных
          выше, просто создав функцию
        </p>
        <pre>
          int NAND(int a, int b) {
            return ~(a&b);
          }
        
          int NOR(int a, int b) {
            return ~(a|b);
          }
        </pre>
        <p>
          Рассмотрим пример. A = 0b1010; B = 0b1011; C = 0b1100; D = 0b1101,
          реализуем выражение:
          <!-- $$\bar A*(D↓C)+(C|B)$$ -->
        </p>
        <img src="./images/module_1/task1-3-1.png" />
        <pre>
          char buffer[100];
          int A = 0b1010;
          int B = 0b1011;
          int C = 0b1100;
          int D = 0b1101;
          HAL_UART_Transmit(&huart1, (uint8_t*)buffer, sprintf(buffer, "%x\n\r",((~A&NAND(D,C))|NOR(C,B))&0xF), 100);
        </pre>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-3-prepare.png" />
          <p>Рисунок 31 Результаты расчёта логического выражения</p>
        </div>
        <p>Выполним проверку</p>
        <img src="./images/module_1/task1-3-2.png" />
        <!-- <tex
          >$$\bar A = 0b0101, (D↓C) = 0b0011, \bar A*(D↓C) = 0b0001, (C|B) =
          0b0000, \bar A*(D↓C)+(C|B) = 0b0001 $$</tex
        > -->
        <p>
          Как видим полученный результат идентичен результату который посчитан
          на микроконтроллере
        </p>
      </section>
      <section id="module1-4">
        <h3>Модуль 1.4. Запись в память</h3>
        <h4>Задание 1.4.1</h4>
        <p>
          Записать в память своё имя и фамилию с помощью ASCII кодов, начиная с
          адреса, соответствующего трём последним цифрам номера телефона. Запись
          сделать в flash память, не раньше ячейки 08002000
        </p>
        <p><a href="https://www.ascii-code.com/">Таблица ASCII кодов</a></p>
        <p>
          Чтобы записать в flash память её надо разблокировать командой
          HAL_FLASH_Unlock(), запись в память осуществляется командой
          HAL_FLASH_Program
        </p>
        <p>
          В приведенном ниже фрагменте программы в память записывается слово "MY
          NAME"
        </p>
        <pre>
          HAL_FLASH_Unlock();
          uint8_t wrBuf[7] = {77, 89, 32, 78, 65, 77, 69 };
          uint32_t flashAddress = 0x08002000;
          for(uint32_t i=0; i<7; i++)
          {
              HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, flashAddress, ((uint8_t *)wrBuf)[i]);
              flashAddress++;
          }
          HAL_FLASH_Lock();
        </pre>
        <p>
          Чтобы посмотреть результат записи, в Proteus нажимаем Debug > CM4 >
          FLASH at 0x08000000
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-4-prepare-1.png" />
          <p>Рисунок 32 Открытие окна просмотра памяти</p>
        </div>
        <p>
          Далее либо проматываем скроллом до нужной ячейки, либо кликаем правой
          кнопкой мыши выбираем "Go to" и вводим нужный адрес
        </p>
        <p>Посмотрим слово записанное тестовой программой</p>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-4-prepare-2.png" />
          <p>Рисунок 33 Записанное слово в памяти</p>
        </div>
        <p>Как видим в памяти записано слово "MY NAME"</p>
        <h4>Задание 1.4.2</h4>
        <p>
          Теперь усложним задачу. Необходимо написать функцию, которая вычисляет
          <a
            href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8"
            >числа Фибоначчи</a
          >
          до 30. Для удобства просмотра в памяти можно сделать запись через 17
          ячеек.
        </p>
        <p>
          Для чётных вариантов сделать вычисление числа Фибоначчи по формуле
          Бине, для нечётных реализовать линейный алгоритм нахождения
        </p>
        <p>
          * Задание повышенной сложности: реализовать вычисление числа Фибоначчи
          <a
            href="http://mech.math.msu.su/~shvetz/54/inf/perl-problems/chFibonacci_sIdeas.xhtml#:~:text=%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%20%D1%8D%D1%82%D0%BE%D0%B3%D0%BE%20%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%BB%D0%B0.-,%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F,-%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B"
            >матричным способом</a
          >
        </p>
        <p>Формула Бине:</p>
        <img src="./images/module_1/task1-4-1.png" />
        <!-- <p>
          $$F_{n} = {{{(1+\sqrt{5})^n\over{2}} -
          {(1-\sqrt{5})^n\over{2}}}\over{\sqrt{5}}}$$
        </p> -->
        <p>Линейный алгоритм</p>
        <img src="./images/module_1/task1-4-2.png" />
        <!-- <p>$$F_{n} = F_{n-1} + F_{n-2}$$</p>
        <p>$$F_{0} = 0, F_{1} = 1$$</p> -->
        <p>Функцию для вычисления числа Фибоначчи реализовать самостоятельно</p>
        <p>
          Возможно при решении данной задачи, может быть непонятно почему ответ
          после 15 числа получается неверный. Ответ прост: одна ячейка памяти
          равна байту, число записывается в память начиная с младшего байта
        </p>
        <p>Для лучшего понимания рассмотрим пример ниже</p>
        <pre>
HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, flashAddress, 0x78563412);</pre
        >
        <p>Как видим из кода в память записывается число 0x78563412</p>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-4-2prepare1.png" />
          <p>Рисунок 34 Запись в память 32х разрядного числа</p>
        </div>
        <p>
          Сначала записался младший байт - 12, далее следующий по старшинству -
          34, далее 56 и в конце 78, в итоге видим 12345678
        </p>
        <p>
          Перейдём к заданию, итоговый результат представлен на рисунке ниже
        </p>
        <div class="imageBlock">
          <img src="./images/module_1/proteus-result-module1-4-2prepare2.png" />
          <p>Рисунок 35 Запись в память чисел Фибоначчи</p>
        </div>
      </section>
    </div>
  </body>
</html>
